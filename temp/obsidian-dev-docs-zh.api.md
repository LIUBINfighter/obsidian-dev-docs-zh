## API Report File for "obsidian-dev-docs-zh"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { App } from 'obsidian';
import type { Application } from 'pixi.js';
import type { BlockCache } from 'obsidian';
import type { BrowserWindow } from 'electron';
import type { CachedMetadata } from 'obsidian';
import type { CacheItem } from 'obsidian';
import type { ChangeDesc } from '@codemirror/state';
import type { CloseableComponent } from 'obsidian';
import type { ColorComponent } from 'obsidian';
import type { Command } from 'obsidian';
import type { Component } from 'obsidian';
import type { Container } from 'pixi.js';
import type { DataAdapter } from 'obsidian';
import type { Debouncer } from 'obsidian';
import type { default as default_2 } from 'moment';
import type { EditableFileView } from 'obsidian';
import type { Editor } from 'obsidian';
import type { EditorPosition } from 'obsidian';
import type { EditorRange } from 'obsidian';
import type { EditorRangeOrCaret } from 'obsidian';
import type { EditorSuggest } from 'obsidian';
import type { EditorView } from '@codemirror/view';
import type { EmbedCache } from 'obsidian';
import type { EventRef } from 'obsidian';
import type { Events } from 'obsidian';
import type { Extension } from '@codemirror/state';
import type { FileStats } from 'obsidian';
import type { FileView } from 'obsidian';
import type { FrontmatterLinkCache } from 'obsidian';
import type { FSWatcher } from 'node:fs';
import type { FuzzySuggestModal } from 'obsidian';
import type { Graphics } from 'pixi.js';
import type { HoverLinkSource } from 'obsidian';
import type { HoverPopover } from 'obsidian';
import type { ICanvas } from 'pixi.js';
import type { IconName } from 'obsidian';
import type { ItemView } from 'obsidian';
import type { KeymapInfo } from 'obsidian';
import type { LinkCache } from 'obsidian';
import type { MarkdownEditView } from 'obsidian';
import type { MarkdownFileInfo } from 'obsidian';
import type { MarkdownPostProcessorContext } from 'obsidian';
import type { MarkdownPreviewView } from 'obsidian';
import type { MarkdownView } from 'obsidian';
import type { Menu } from 'obsidian';
import type { Modal } from 'obsidian';
import type { PaneType } from 'obsidian';
import type { ParseContext } from '@codemirror/language';
import type { Plugin as Plugin_2 } from 'obsidian';
import type { PluginManifest } from 'obsidian';
import type { PluginSettingTab } from 'obsidian';
import type { PopoverSuggest } from 'obsidian';
import type { Reference } from 'obsidian';
import type { ReferenceCache } from 'obsidian';
import type { Scope } from 'obsidian';
import type { SearchComponent } from 'obsidian';
import type { SearchQuery } from '@codemirror/search';
import type { SearchResult } from 'obsidian';
import type { Setting } from 'obsidian';
import type { SettingTab } from 'obsidian';
import type { SplitDirection } from 'obsidian';
import type { Sprite } from 'pixi.js';
import type { TAbstractFile } from 'obsidian';
import type { Text as Text_2 } from 'pixi.js';
import type { TextComponent } from 'obsidian';
import type { TextFileView } from 'obsidian';
import type { TextStyle } from 'pixi.js';
import type { TFile } from 'obsidian';
import type { TFolder } from 'obsidian';
import type { Transaction } from '@codemirror/state';
import type { Tree as Tree_2 } from '@lezer/common';
import type { Vault } from 'obsidian';
import type { View } from 'obsidian';
import type { ViewCreator } from 'obsidian';
import type { ViewState } from 'obsidian';
import type { ViewUpdate } from '@codemirror/view';
import type { Workspace } from 'obsidian';
import type { WorkspaceLeaf } from 'obsidian';
import type { WorkspaceTabs } from 'obsidian';

// @public
export interface AbsFunction extends BasesFunction, HasGetDisplayName {
}

// @public
export interface AbstractFileTreeItem<T extends TAbstractFile> extends TreeItem {
    	file: T;
    	getTitle(): string;
    	info: TreeNodeInfo;
    	isFullTimeShown(): boolean;
    	onRender(): void;
    	parent: FileTreeItemParent;
    	rendered: boolean;
    	startRename(): void;
    	stopRename(): void;
    	updateTitle(): void;
    	view: FileExplorerView;
}

// @public
export interface AbstractSearchComponent {
    	app: App;
    	containerEl: HTMLElement;
    	getQuery(): string;
    	goToNextInput(event: KeyboardEvent): unknown;
    	onEnter(event: KeyboardEvent): unknown;
    	onShiftEnter(event: KeyboardEvent): unknown;
    	replaceInputEl: HTMLInputElement;
    	scope: Scope;
    	searchButtonContainerEl: HTMLElement;
    	searchContainerEl: HTMLElement;
    	searchInputEl: HTMLInputElement;
}

// @public
export interface Account {
    	company: string;
    	email: string;
    	expiry: number;
    	key: string | undefined;
    	keyValidation: string;
    	license: "" | "insider";
    	name: string;
    	seats: number;
    	token: string;
}

// @public
export interface AddOverlayOptions {
    	query: RegExp;
}

// @public
export interface AliasesPropertyWidgetComponent extends PropertyWidgetComponentBase {
    	ctx: PropertyRenderContext;
    	hoverPopover: HoverPopover | null;
    	multiselect: Multiselect;
    	type: "aliases";
}

// @public
export interface AllPropertiesView extends ItemView {
    	acceptRename(): Promise<void>;
    	cancelRename(): void;
    	exitRename(): void;
    	getViewType(): typeof ViewType.AllProperties;
    	isItem(e: unknown): boolean;
    	onKeyEnterInFocus(event: KeyboardEvent): void;
    	onKeyEnterInRename(event: KeyboardEvent): void;
    	onToggleShowSearch(): void;
    	setShowSearch(e: boolean): void;
    	setSortOrder(order: unknown): void;
    	showSearch(): void;
    	startRename(e: unknown): Promise<unknown>;
    	update(): void;
    	updateSearch(): void;
}

// @public
export interface AllPropertiesViewConstructor extends TypedViewConstructor<AllPropertiesView> {
}

// @public
export interface AppConstructor extends ConstructorBase<[
	adapter: DataAdapter,
	appId: string
], App> {
}

// @public
export interface AppMenuBarManager {
    	app: App;
    	applyHotkeys(arg1: unknown): unknown;
    	buildMenu(): unknown;
    	constructor: AppMenuBarManagerConstructor;
    	getAcceleratorFromHotkey(arg1: unknown): unknown;
    	hideUnregisteredCommands(arg1: unknown): unknown;
    	onLayoutChange: Debouncer<[
    	], unknown>;
    	_onLayoutChange(): unknown;
    	onWindowFrameChange: Debouncer<[
    	], unknown>;
    	render(): unknown;
    	requestRender: Debouncer<[
    	], unknown>;
    	updateShareMenuItem(arg1: unknown): unknown;
    	updateViewState(): unknown;
    	updateWorkspace(): unknown;
}

// @public
export interface AppMenuBarManagerConstructor {
    	updateMenuItems(arg1: unknown, arg2: unknown): unknown;
}

// @public
export interface AppSetting extends Modal {
    	activeTab: SettingTab | null;
    	activeTabCloseable: CloseableComponent | null;
    	addSettingTab(tab: SettingTab): void;
    	closeActiveTab(): void;
    	communityPluginTabContainer: HTMLElement;
    	communityPluginTabHeaderGroup: HTMLElement;
    	corePluginTabContainer: HTMLElement;
    	corePluginTabHeaderGroup: HTMLElement;
    	isPluginSettingTab(tab: SettingTab): boolean;
    	lastTabId: string;
    	openTab(tab: SettingTab): void;
    	openTabById(id: "hotkeys"): HotkeysSettingTab;
    	openTabById(id: string): SettingTab;
    	pluginTabs: SettingTab[];
    	removeSettingTab(tab: SettingTab): void;
    	settingTabs: SettingTab[];
    	tabContainer: HTMLElement;
    	tabContentContainer: HTMLElement;
    	tabHeadersEl: HTMLElement;
    	updateModalTitle(tab: SettingTab): void;
    	updatePluginSection(): void;
}

// @public
export interface AppVaultConfig {
    	accentColor: "" | string;
    	alwaysUpdateLinks?: false | boolean;
    	attachmentFolderPath?: "/" | string;
    	autoConvertHtml?: true | boolean;
    	autoPairBrackets?: true | boolean;
    	autoPairMarkdown?: true | boolean;
    	baseFontSize?: 16 | number;
    	baseFontSizeAction?: true | boolean;
    	communityPluginSortOrder: "download" | "update" | "release" | "alphabetical";
    	communityThemeSortOrder: "download" | "update" | "release" | "alphabetical";
    	cssTheme?: "" | string;
    	defaultViewMode?: "source" | "preview";
    	emacsyKeys?: true | boolean;
    	enabledCssSnippets?: string[];
    	fileSortOrder?: "alphabetical";
    	focusNewTab?: true | boolean;
    	foldHeading?: true | boolean;
    	foldIndent?: true | boolean;
    	// @deprecated
    hotkeys?: AppVaultConfigHotkeysRecord;
    	interfaceFontFamily?: "" | string;
    	legacyEditor?: false | boolean;
    	livePreview?: true | boolean;
    	mobilePullAction?: "command-palette:open" | string;
    	mobileQuickRibbonItem?: "" | string;
    	mobileToolbarCommands?: string[];
    	monospaceFontFamily?: "" | string;
    	nativeMenus?: null | boolean;
    	newFileFolderPath?: "/" | string;
    	newFileLocation?: "root" | "current" | "folder";
    	newLinkFormat?: "shortest" | "relative" | "absolute";
    	pdfExportSettings?: PdfExportSettings;
    	promptDelete?: true | boolean;
    	propertiesInDocument?: "visible" | "hidden" | "source";
    	readableLineLength?: true | boolean;
    	rightToLeft?: false | boolean;
    	showIndentGuide?: true | boolean;
    	showInlineTitle?: true | boolean;
    	showLineNumber?: false | boolean;
    	showRibbon?: true | boolean;
    	showUnsupportedFiles?: false | boolean;
    	showViewHeader?: false | boolean;
    	smartIndentList?: true | boolean;
    	spellcheck?: false | boolean;
    	spellcheckLanguages?: null | string[];
    	strictLineBreaks?: false | boolean;
    	tabSize?: 4 | number;
    	textFontFamily?: "" | string;
    	theme?: "moonstone" | "obsidian";
    	translucency?: false | boolean;
    	trashOption?: "system" | "local" | "none";
    	// @deprecated (undocumented)
    types: object;
    	useMarkdownLinks?: false | boolean;
    	userIgnoreFilters?: null | string[];
    	useTab?: true | boolean;
    	vimMode?: false | boolean;
}

// @public
export interface AppVaultConfigHotkeysRecord extends Record<string, string> {
}

// @public
export interface AudioRecorderPlugin extends InternalPlugin<AudioRecorderPluginInstance> {
}

// @public
export interface AudioRecorderPluginInstance extends InternalPluginInstance<AudioRecorderPlugin> {
    	app: App;
    	checkPermission(): Promise<boolean>;
    	extension: string;
    	onRecordAudio(): Promise<void>;
    	onStartRecording(): Promise<void>;
    	onStopRecording(): void;
    	plugin: AudioRecorderPlugin;
    	recorder: MediaRecorder | null;
    	recording: boolean;
    	saveRecording(audioBuffer: ArrayBuffer): Promise<void>;
    	showRecordingMessage(message: string, isError: boolean): void;
    	startRecording(stream: MediaStream): void;
}

// @public
export interface AudioView extends EditableFileView {
    	getViewType(): typeof ViewType.Audio;
}

// @public
export interface AudioViewConstructor extends TypedViewConstructor<AudioView> {
}

// @public
export interface BacklinkComponent extends Component {
    	addLinkFunction(arg1: unknown, arg2: unknown, arg3: unknown): unknown;
    	app: App;
    	backlinkCollapsed: boolean;
    	backlinkCountEl: HTMLSpanElement;
    	backlinkDom: ResultDom;
    	backlinkFile: TFile | null;
    	backlinkHeaderEl: HTMLDivElement;
    	backlinkQueue: ItemQueue<TFile> | null;
    	collapseAll: boolean;
    	collapseAllButtonEl: HTMLDivElement;
    	extraContext: boolean;
    	extraContextButtonEl: HTMLDivElement;
    	file: TFile | null;
    	getState(): unknown;
    	headerDom: HeaderDom;
    	isShowingSearch: boolean;
    	onFileChanged(arg1: unknown): unknown;
    	onFileDeleted(arg1: unknown): unknown;
    	onFileRename(arg1: unknown): unknown;
    	onload(): unknown;
    	onMetadataChanged(arg1: unknown): unknown;
    	onResize(): unknown;
    	onToggleCollapseClick(): unknown;
    	onToggleMoreContextClick(): unknown;
    	onToggleShowSearch(): unknown;
    	passSearchFilter(arg1: unknown, arg2: unknown): unknown;
    	recomputeBacklink(backlinkFile: TFile | null): void;
    	recomputeUnlinked(arg1: unknown): unknown;
    	searchComponent: SearchComponent;
    	searchQuery: null;
    	setBacklinkCollapsed(arg1: unknown, arg2: unknown): Promise<unknown>;
    	setCollapseAll(arg1: unknown): unknown;
    	setExtraContext(arg1: unknown): unknown;
    	setSectionCollapsed(arg1: unknown, arg2: unknown, arg3: unknown, arg4: unknown): Promise<unknown>;
    	setShowSearch(arg1: unknown): unknown;
    	setSortOrder(arg1: unknown): unknown;
    	setState(arg1: unknown): Promise<unknown>;
    	setUnlinkedCollapsed(arg1: unknown, arg2: unknown): Promise<unknown>;
    	showSearchButtonEl: HTMLDivElement;
    	sortOrder: string;
    	stopBacklinkSearch(): void;
    	stopUnlinkedSearch(): unknown;
    	toggleBacklinkCollapsed(): unknown;
    	toggleUnlinkedCollapsed(): unknown;
    	tooltipPlacement: string;
    	unlinkedAliases: string;
    	unlinkedCollapsed: boolean;
    	unlinkedCountEl: HTMLSpanElement;
    	unlinkedDom: ResultDom;
    	unlinkedFile: null;
    	unlinkedHeaderEl: HTMLDivElement;
    	unlinkedQueue: null;
    	update(): unknown;
    	updateHeaderTooltip(arg1: unknown, arg2: unknown): unknown;
    	updateSearch(): unknown;
}

// @public
export interface BacklinkPlugin extends InternalPlugin<BacklinkPluginInstance> {
    	views: BacklinkPluginViews;
}

// @public
export interface BacklinkPluginInstance extends InternalPluginInstance<BacklinkPlugin> {
    	app: App;
    	defaultOn: true;
    	file?: TFile | null;
    	initLeaf(): void;
    	onEnable(app: App, plugin: BacklinkPlugin): Promise<void>;
    	onExternalSettingsChange(): Promise<void>;
    	onFileMenu(menu: Menu, file: TAbstractFile, source: string, leaf?: WorkspaceLeaf): void;
    	onFileOpen(file: TAbstractFile): void;
    	onUserDisable(app: App): void;
    	onUserEnable(): void;
    	openBacklinksForActiveFile(skipSplit: boolean): boolean | undefined;
    	options: BacklinkPluginInstanceOptions;
    	plugin: BacklinkPlugin;
    	toggleBacklinksInDocument(skip: boolean): boolean | undefined;
    	updateBacklinks(): void;
}

// @public
export interface BacklinkPluginInstanceOptions {
    	backlinkInDocument?: boolean;
}

// @public
export interface BacklinkPluginViews extends Record<string, ViewCreator> {
    	backlink(left: WorkspaceLeaf): BacklinkView;
}

// @public
export interface BacklinkView extends InfoFileView {
    	backlink: BacklinkComponent;
    	getViewType(): typeof ViewType.Backlink;
    	showSearch(): void;
    	update(): void;
}

// @public
export interface BacklinkViewConstructor extends TypedViewConstructor<BacklinkView> {
}

// @public
export interface BasesContext extends Component {
    	_local: BasesLocal;
}

// @public
export interface BasesContextConstructor extends ConstructorBase<[
	app: App,
	filter: Record<string, BasesFilter>,
	formulas: Record<string, BasesFormula>,
	file: TFile | null
], BasesContext> {
}

// @public
export interface BasesControl {
    	renderTo(containerEl: HTMLElement, renderContext: RenderContext): void;
}

// @public
export interface BasesController extends Component {
    	addResult(result: unknown, arg2: unknown): unknown;
    	app: App;
    	buildBasesContext(filter: BasesFilter): BasesContext;
    	clear(): void;
    	clearError(): void;
    	ctx: BasesContext;
    	currentFile: TFile | null;
    	displayError(error: string, arg2: unknown): void;
    	error: string | null;
    	errorEl: HTMLDivElement;
    	errors: Set<string>;
    	evaluateRelevantProperties(relevantProperties: string[]): void;
    	events: Events;
    	filterMenu: BasesFilterMenu;
    	getActiveBasesViewOfType(viewType: string): View | null;
    	getCurrentFile(): TFile | null;
    	getEditorLanguageSupport(): EditorLanguageSupport;
    	getMockValue(arg1: unknown): unknown;
    	getMockValueForIdent(arg1: unknown): unknown;
    	getProperties(): unknown[];
    	getQueryViewNames(): string[];
    	getViewConfig(): unknown;
    	getWidgetForIdent(type: string): string;
    	initialScan: boolean;
    	mockContext: BasesMockContext;
    	newItemMenu: BasesNewItemMenu;
    	notifyView(): void;
    	onConfigChanged(configKey: string): void;
    	onResize(): void;
    	plugin: BasesPluginInstance;
    	promptForAddView(): void;
    	propertyMenu: BasesPropertyMenu;
    	query: BasesQuery | null;
    	queryState: string;
    	queue: PromisedQueue;
    	relevantProperties: Set<string>;
    	removeResult(arg1: unknown): unknown;
    	requestNotifyView: Debouncer<[
    	], void>;
    	results: Map<unknown, unknown>;
    	resultsMenu: BasesResultsMenu;
    	runQuery(arg1: unknown): void;
    	selectView(viewName: string): void;
    	setQuery(queryOrError: BasesQuery | Error): void;
    	setQueryAndView(queryOrError: BasesQuery | Error, viewName: string): void;
    	sortMenu: BasesSortMenu;
    	startLoader(): void;
    	stopLoader(): void;
    	update(): void;
    	updateCurrentFile(file: TFile): void;
    	view: View;
    	viewContainerEl: HTMLDivElement;
    	viewEstates: Record<string, unknown>;
    	viewHeaderEl: HTMLDivElement;
    	viewMenu: BasesViewMenu;
    	viewName: string;
}

// @public
export interface BasesExternalLink extends BasesControl {
}

// @public
export interface BasesFile extends BasesControl {
    	getLinks(): BasesList;
}

// @public
export interface BasesFilter {
}

// @public
export interface BasesFilterMenu {
}

// @public
export interface BasesFormula {
}

// @public
export interface BasesFunction {
    	app: App;
    	apply(...args: unknown[]): unknown;
    	args: BasesFunctionArg[];
    	isOperator: boolean;
    	name: string;
    	returnType: string;
    	serialize(...args: unknown[]): string;
}

// @public
export interface BasesFunctionArg {
    	include_custom_types?: boolean;
    	name: string;
    	optional?: boolean;
    	type: string[];
    	variadic?: boolean;
}

// @public
export interface BasesFunctions {
    	"!=": NotEqualFunction;
    	"<": LessFunction;
    	"<=": LessOrEqualFunction;
    	"==": EqualFunction;
    	">": GreaterFunction;
    	">=": GreaterOrEqualFunction;
    	abs: AbsFunction;
    	ceil: CeilFunction;
    	concat: ConcatFunction;
    	contains: ContainsFunction;
    	containsAll: ContainsAllFunction;
    	containsAny: ContainsAnyFunction;
    	containsNone: ContainsNoneFunction;
    	dateAfter: DateAfterFunction;
    	dateBefore: DateBeforeFunction;
    	dateDiff: DateDiffFunction;
    	dateEquals: DateEqualsFunction;
    	dateModify: DateModifyFunction;
    	dateNotEquals: DateNotEqualsFunction;
    	dateOnOrAfter: DateOnOrAfterFunction;
    	dateOnOrBefore: DateOnOrBeforeFunction;
    	day: DayFunction;
    	empty: EmptyFunction;
    	flat: FlatFunction;
    	floor: FloorFunction;
    	hour: HourFunction;
    	if: IfFunction;
    	index: IndexFunction;
    	inFolder: InFolderFunction;
    	join: JoinFunction;
    	len: LenFunction;
    	linksTo: LinksToFunction;
    	min: MinFunction;
    	minute: MinuteFunction;
    	month: MonthFunction;
    	not: NotFunction;
    	notContains: NotContainsFunction;
    	notEmpty: NotEmptyFunction;
    	now: NowFunction;
    	round: RoundFunction;
    	second: SecondFunction;
    	slice: SliceFunction;
    	taggedWith: TaggedWithFunction;
    	title: TitleFunction;
    	trim: TrimFunction;
    	unique: UniqueFunction;
    	year: YearFunction;
}

// @public
export interface BasesHandlers extends Record<string, ViewFactory> {
    	table: ViewFactory<TableView>;
}

// @public
export interface BasesLink extends BasesControl {
    	link: string;
}

// @public
export interface BasesLinkConstructor extends ConstructorBase<[
	app: App,
	linkText: string,
	sourcePath: string,
	displayText: string
], BasesLink> {
    	parseFromString(app: App, str: string, sourcePath: string): BasesLink;
}

// @public
export interface BasesList extends BasesControl {
    	data: Record<string, BasesControl>;
    	get(key: string): BasesControl;
}

// @public
export interface BasesLocal {
    	implicit: BasesFile;
    	note: BasesNote;
}

// @public
export interface BasesMockContext {
}

// @public
export interface BasesNewItemMenu {
}

// @public
export interface BasesNote {
    	data: Record<string, unknown>;
    	get(key: string): BasesControl;
}

// @public
export interface BasesPlugin extends InternalPlugin<BasesPluginInstance> {
}

// @public
export interface BasesPluginInstance extends InternalPluginInstance<BasesPlugin> {
    	app: App;
    	createAndEmbedBase(editor: Editor): Promise<void>;
    	createNewBasesFile(location?: TFolder, filename?: string, contents?: string): Promise<TFile>;
    	defaultOn: boolean;
    	deregisterFunction(name: string): void;
    	deregisterView(type: string): void;
    	functions: BasesFunctions;
    	getFunction(name: string): BasesFunction | null;
    	getOperatorFunctions(): BasesFunction[];
    	getViewFactory(type: string): ViewFactory | null;
    	getViewTypes(): string[];
    	handlers: BasesHandlers;
    	onFileMenu(menu: Menu, file: TAbstractFile, source: string, leaf?: WorkspaceLeaf): void;
    	registerFunction(fn: BasesFunction): void;
    	registerView(type: string, viewFactory: ViewFactory): void;
}

// @public
export interface BasesProperty {
    	getDisplayName(): string;
    	migrateDisplayName(getDisplayName: string): string;
    	propertyId: string;
    	query: BasesQuery;
    	serialize(): object;
    	setDisplayName(displayName: string): void;
    	unrecognizedData: object;
}

// @public
export interface BasesPropertyMenu {
}

// @public
export interface BasesQuery {
    	clone(): this;
    	formulas: Record<string, BasesFormula>;
    	getPropertyConfig(key: string): unknown;
    	getSerializable(): object;
    	getViewConfig(key: string): unknown;
    	properties: Record<string, BasesProperty>;
    	removeFormula(key: string): void;
    	save(): void;
    	saveFn(query: this): void;
    	setFormulas(formulas: Record<string, BasesFormula>): void;
    	setGlobalFilters(filter: BasesFilter): void;
    	setViewFilters(key: string, filters: BasesFilter): void;
    	unrecognizedData: object;
    	views: BasesSubView[];
}

// @public
export interface BasesResultsMenu {
}

// @public
export interface BasesSortMenu {
}

// @public
export interface BasesSubView {
    	clone(name: string): this;
    	get(arg1: unknown): unknown;
    	getAll(): unknown;
    	getDisplayName(arg1: unknown): unknown;
    	getLimit(): unknown;
    	getOrder(): unknown;
    	getPropertyConfig(arg1: unknown): unknown;
    	getSort(): unknown;
    	getViewName(): string;
    	name: string;
    	query: BasesQuery;
    	serialize(): SerializedBasesSubView;
    	set(arg1: unknown, arg2: unknown): unknown;
    	setLimit(arg1: unknown): unknown;
    	setOrder(arg1: unknown): unknown;
    	setSortProperty(arg1: unknown, arg2: unknown): unknown;
    	type: string;
}

// @public
export interface BasesView extends TextFileView {
    	controller: BasesController;
    	getViewType(): typeof ViewType.Bases;
    	lastData: string;
    	onLayoutChange(): void;
    	onViewChanged(): void;
    	plugin: BasesPluginInstance;
    	query: BasesQuery;
    	receiveSyncState(fileView: FileView): void;
    	saveQuery(query: BasesQuery): void;
    	updateCurrentFile(file: TFile | null): void;
}

// @public
export interface BasesViewConstructor extends TypedViewConstructor<BasesView, [
	basesPluginInstance: BasesPluginInstance
]> {
}

// @public
export interface BasesViewMenu {
}

// @public
export interface BBox {
    	maxX: number;
    	maxY: number;
    	minX: number;
    	minY: number;
}

// @public
export interface Bezier {
    	cp1: Pointer;
    	cp2: Pointer;
    	from: Pointer;
    	path: string;
    	to: Pointer;
}

// @public
export interface Bookmark {
    	assoc: number;
    	clear(): void;
    	cm: CodeMirrorEditor;
    	find(): EditorPosition | null;
    	id: number;
    	offset: number;
    	update(changeDesc: ChangeDesc): void;
}

// @public
export interface BookmarkItem {
    	ctime: number;
    	items?: BookmarkItem[];
    	path?: string;
    	query?: string;
    	subpath?: string;
    	title: string;
    	type: "file" | "folder" | "group" | "graph" | "search" | "url";
    	url?: string;
}

// @public
export interface BookmarksPlugin extends InternalPlugin<BookmarksPluginInstance> {
    	views: BookmarksPluginViews;
}

// @public
export interface BookmarksPluginInstance extends InternalPluginInstance<BookmarksPlugin>, Events {
    	addItem(item: BookmarkItem, instance?: BookmarksPluginInstance): void;
    	app: App;
    	bookmarkedViews: WeakMap<View, HTMLElement>;
    	bookmarkLookup: Record<string, BookmarkItem>;
    	defaultOn: true;
    	editItem(item: BookmarkItem): void;
    	findBookmarkByView(view: FileView): BookmarkItem | null | undefined;
    	getBookmarks(): BookmarkItem[];
    	getItemTitle(item: BookmarkItem): string;
    	hasValidData: boolean;
    	initLeaf(): void;
    	items: BookmarkItem[];
    	loadData(): Promise<boolean>;
    	moveItem(item: BookmarkItem, instance: BookmarksPluginInstance | undefined, index: number): void;
    	onEditorMenu(menu: Menu, editor: Editor, info: MarkdownView | MarkdownFileInfo): void;
    	onEnable(app: App, plugin: BookmarksPlugin): Promise<void>;
    	onExternalSettingsChange(): Promise<void>;
    	onFileMenu(menu: Menu, files: TAbstractFile[], source: string, leaf?: WorkspaceLeaf): void;
    	onFileRename(file: TFile, oldPath: string): void;
    	onFilesMenu(menu: Menu, files: TAbstractFile[], source: string, leaf?: WorkspaceLeaf): void;
    	onItemsChanged: Debouncer<[
    		boolean
    	], void>;
    	_onItemsChanged(shouldSave: boolean): void;
    	onLeafMenu(menu: Menu, leaf: WorkspaceLeaf): void;
    	onSearchResultsMenu(menu: Menu, search: TypedWorkspaceLeaf<SearchView>): void;
    	onTabGroupMenu(menu: Menu, tabsLeaf: WorkspaceTabs): void;
    	onUserEnable(): void;
    	openBookmark(item: BookmarkItem, newLeaf: PaneType | boolean, newLeaf2?: PaneType | boolean): Promise<void>;
    	openBookmarkInLeaf(item: BookmarkItem, leaf: WorkspaceLeaf, newLeaf?: PaneType | boolean): Promise<void>;
    	openBookmarks(items: BookmarkItem[], newLeaf?: PaneType | boolean): Promise<void>;
    	plugin: BookmarksPlugin;
    	rebuildBookmarkCache(): void;
    	removeItem(item: BookmarkItem): void;
    	saveData(): void;
    	updateTabHeaders(): void;
    	urlBookmarkLookup: Record<string, BookmarkItem>;
}

// @public
export interface BookmarksPluginViews extends Record<string, ViewCreator> {
    	bookmarks(left: WorkspaceLeaf): BookmarksView;
}

// @public
export interface BookmarksView extends ItemView {
    	attachDragHandler(e: unknown): void;
    	attachDropHandler(): void;
    	_copyToClipboard(e: unknown, t: unknown): void;
    	createNewGroup(e: unknown): void;
    	dragSelectedBookmarks(e: unknown, t: unknown): unknown | null;
    	_getActiveBookmarks(): unknown[];
    	getItemDom(e: unknown): unknown;
    	getNodeId(e: unknown): string;
    	getViewType(): typeof ViewType.Bookmarks;
    	handleCollapseAll(e: unknown): void;
    	isItem(item: unknown): boolean;
    	onContextMenu(event: unknown): void;
    	onDeleteSelectedItems(event: unknown): unknown;
    	onFileCreate(file: TFile): void;
    	onFileDelete(file: TFile): void;
    	onFileOpen(file: TFile): void;
    	onRenameKey(event: KeyboardEvent): void;
    	update(): void;
}

// @public
export interface BookmarksViewConstructor extends TypedViewConstructor<BookmarksView, [
	bookmarksPluginInstance: BookmarksPluginInstance
]> {
}

// @public
export interface Bracket {
    	ch: string;
    	pos: EditorPosition;
}

// @public
export interface Btime {
    	btime(path: string, btime: number): void;
}

// @public
export interface CanvasConnection {
}

// @public
export interface CanvasDataManager {
    	app: App;
    	handleDelete(arg1: unknown): unknown;
    	handleRename(arg1: unknown, arg2: unknown): unknown;
    	load(arg1: unknown): unknown;
    	remove(arg1: unknown): unknown;
    	save(arg1: unknown, arg2: unknown): unknown;
}

// @public
export interface CanvasEmbed {
    	file: string;
    	subpath?: string;
}

// @public
export interface CanvasIndex extends Component {
    	app: App;
    	canProcess(arg1: unknown): unknown;
    	fileQueue: unknown[];
    	frame: null;
    	get(arg1: unknown): unknown;
    	getAll(): unknown;
    	getForPath(arg1: unknown): unknown;
    	index: Record<string, CanvasIndexEntry>;
    	onCreate(arg1: unknown): unknown;
    	onDelete(arg1: unknown): unknown;
    	onload(): unknown;
    	onModify(arg1: unknown): unknown;
    	onRename(arg1: unknown, arg2: unknown): unknown;
    	onunload(): unknown;
    	parseText(arg1: unknown): Promise<unknown>;
    	process(arg1: unknown): Promise<unknown>;
    	queue(arg1: unknown): unknown;
    	refNodeIds: WeakMap<object, unknown>;
    	requestFrame(): unknown;
    	run(): Promise<unknown>;
}

// @public
export interface CanvasIndexEntry {
    	caches: Record<string, CachedMetadata>;
    	embeds: CanvasEmbed[];
}

// @public
export interface CanvasLinkUpdater extends LinkUpdater {
    	app: App;
    	canvas: CanvasPluginInstance;
}

// @public
export interface CanvasMenu {
    	canvas: CanvasViewCanvas;
    	containerEl: HTMLDivElement;
    	menuEl: HTMLDivElement;
    	render(arg1: unknown): unknown;
    	selection: CanvasSelection;
    	updateZIndex(arg1: unknown): unknown;
}

// @public
export interface CanvasNode {
}

// @public
export interface CanvasPlugin extends InternalPlugin<CanvasPluginInstance> {
}

// @public
export interface CanvasPluginInstance extends InternalPluginInstance<CanvasPlugin> {
    	app: App;
    	defaultOn: true;
    	index: CanvasIndex;
    	localDataManager: CanvasDataManager;
    	options: CanvasPluginInstanceOptions;
    	plugin: CanvasPlugin;
    	renameQueue: PromisedQueue;
    	renames: unknown[];
    	requestProcessRename: Debouncer<[
    	], unknown>;
}

// @public
export interface CanvasPluginInstanceOptions {
    	cardLabelVisibility?: "always" | "hover" | "never";
    	defaultModDragBehavior?: "card" | "group" | "media" | "menu" | "note" | "webpage";
    	defaultWheelBehavior?: "pan" | "zoom";
    	newFileFolderPath?: string;
    	newFileLocation?: "root" | "current" | "folder";
    	snapToGrid?: boolean;
    	snapToObjects?: boolean;
    	zoomBreakpoint?: number;
}

// @public
export interface CanvasRectEx {
    	cx: number;
    	cy: number;
    	height: number;
    	left: number;
    	maxX: number;
    	maxY: number;
    	minX: number;
    	minY: number;
    	top: number;
    	width: number;
}

// @public
export interface CanvasSelection {
    	bbox: BBox;
    	canvas: CanvasViewCanvas;
    	hide(): unknown;
    	onResizePointerdown(arg1: unknown, arg2: unknown): unknown;
    	resizerEls: HTMLDivElement[];
    	selectionEl: HTMLDivElement;
    	update(arg1: unknown): unknown;
}

// @public
export interface CanvasView extends TextFileView {
    	canvas: CanvasViewCanvas;
    	getLocalData(): unknown;
    	getViewType(): typeof ViewType.Canvas;
    	hoverPopover: null | HoverPopover;
    	plugin: CanvasPluginInstance;
    	saveLocalData(): void;
}

// @public
export interface CanvasViewCanvas {
    	addEdge(arg1: unknown): unknown;
    	addNode(arg1: unknown): unknown;
    	app: App;
    	applyHistory(arg1: unknown): unknown;
    	backgroundPatternEl: SVGPatternElement;
    	cancelFrame(): unknown;
    	canSnap(arg1: unknown): unknown;
    	canvasControlsEl: HTMLDivElement;
    	canvasEl: HTMLDivElement;
    	canvasRect: CanvasRectEx;
    	cardMenuEl: HTMLDivElement;
    	clear(): unknown;
    	clearSnapPoints(): unknown;
    	cloneData(arg1: unknown, arg2: unknown): unknown;
    	config: CanvasViewConfig;
    	createFileNode(arg1: unknown): unknown;
    	createFileNodes(arg1: unknown, arg2: unknown): unknown;
    	createGroupNode(arg1: unknown): unknown;
    	createLinkNode(arg1: unknown): unknown;
    	createPlaceholder(): unknown;
    	createTextNode(arg1: unknown): unknown;
    	data: CanvasViewData;
    	deleteSelection(): unknown;
    	deselect(arg1: unknown): unknown;
    	deselectAll(): unknown;
    	dirty: Set<unknown>;
    	domFromPos(arg1: unknown): unknown;
    	domPosFromClient(arg1: unknown): unknown;
    	domPosFromEvt(arg1: unknown): unknown;
    	dragTempNode(arg1: unknown, arg2: unknown, arg3: unknown): unknown;
    	edgeContainerEl: SVGElement;
    	edgeEndContainerEl: SVGElement;
    	edgeFrom: MapOfSets<CanvasViewCanvasEdge, CanvasViewCanvasNode>;
    	edgeIndex: EdgeIndex;
    	edges: Map<string, CanvasViewCanvasEdge>;
    	edgeTo: MapOfSets<CanvasViewCanvasEdge, CanvasViewCanvasNode>;
    	endSnapPointRendering(): unknown;
    	finishViewportAnimation: boolean;
    	frame: number;
    	frameWin: null;
    	generateHDImage(): Promise<unknown>;
    	getContainingNodes(arg1: unknown): unknown;
    	getData(): unknown;
    	getEdgesForNode(arg1: unknown): unknown;
    	getIntersectingEdges(arg1: unknown): unknown;
    	getIntersectingNodes(arg1: unknown): unknown;
    	getSelectionData(arg1: unknown): unknown;
    	getSnapping(arg1: unknown, arg2: unknown, arg3: unknown, arg4: unknown): unknown;
    	getState(): unknown;
    	getViewportBBox(): unknown;
    	getViewportNodes(arg1: unknown): unknown;
    	getZIndex(): unknown;
    	gridSpacing: number;
    	handleCopy(arg1: unknown): unknown;
    	handleCut(arg1: unknown): unknown;
    	handleDragToSelect(arg1: unknown, arg2: unknown, arg3: unknown): unknown;
    	handleDragWithPan(arg1: unknown, arg2: unknown): unknown;
    	handleMoverPointerdown(arg1: unknown): unknown;
    	handlePaste(arg1: unknown): unknown;
    	handleSelectionDrag(arg1: unknown, arg2: unknown, arg3: unknown): unknown;
    	history: CanvasViewHistory;
    	hitTestNode(arg1: unknown, arg2: unknown): unknown;
    	importData(arg1: unknown, arg2: unknown): unknown;
    	interactionHitTest(arg1: unknown): unknown;
    	isDragging: boolean;
    	isHoldingSpace: boolean;
    	keys: Object;
    	lastEdgesInViewport: Set<CanvasViewCanvasEdge>;
    	lastNodesInViewport: Set<CanvasViewCanvasNode>;
    	load(): unknown;
    	markDirty(arg1: unknown): unknown;
    	markMoved(arg1: unknown): unknown;
    	markViewportChanged(): unknown;
    	menu: CanvasMenu;
    	moved: Set<unknown>;
    	moverEl: HTMLDivElement;
    	nodeIndex: EdgeIndex;
    	nodeInteractionLayer: NodeInteractionLayer;
    	nodes: Map<string, CanvasViewCanvasNode>;
    	nudgeSelection(arg1: unknown, arg2: unknown): unknown;
    	onContextMenu(arg1: unknown): unknown;
    	onDoubleClick(arg1: unknown): unknown;
    	onGlobalKeydown(arg1: unknown): unknown;
    	onGlobalKeyup(arg1: unknown): unknown;
    	onKeydown(arg1: unknown): unknown;
    	onPointerdown(arg1: unknown): unknown;
    	onPointermove(arg1: unknown): unknown;
    	onPriorityPointerdown(arg1: unknown): unknown;
    	onResize(): unknown;
    	onSelectionContextMenu(arg1: unknown): unknown;
    	onTouchdown(arg1: unknown): unknown;
    	onWheel(arg1: unknown): unknown;
    	options?: unknown;
    	overrideHistory(): unknown;
    	panBy(arg1: unknown, arg2: unknown): unknown;
    	panIntoView(arg1: unknown, arg2: unknown): unknown;
    	panTo(arg1: unknown, arg2: unknown): unknown;
    	pauseAnimation: number;
    	pointer: Pointer;
    	pointerFrame: number;
    	pointerFrameWin: null;
    	posCenter(): unknown;
    	posFromClient(arg1: unknown): unknown;
    	posFromDom(arg1: unknown): unknown;
    	posFromEvt(arg1: unknown): unknown;
    	posInViewport(arg1: unknown): unknown;
    	pushHistory(arg1: unknown): unknown;
    	quickSettingsButton: HTMLDivElement;
    	readonly: boolean;
    	redo(): unknown;
    	redoBtnEl: HTMLDivElement;
    	removeEdge(arg1: unknown): unknown;
    	removeNode(arg1: unknown): unknown;
    	renderSnapPoints(arg1: unknown, arg2: unknown, arg3: unknown, arg4: unknown): unknown;
    	requestFrame(arg1: unknown): unknown;
    	requestPushHistory: Debouncer<[
    	], unknown>;
    	requestSave(arg1: unknown): unknown;
    	requestUpdateFileOpen: Debouncer<[
    	], unknown>;
    	rerenderViewport(): unknown;
    	scale: number;
    	screenshotting: boolean;
    	select(arg1: unknown): unknown;
    	selectAll(arg1: unknown): unknown;
    	selection: Set<Selection>;
    	selectionChanged: boolean;
    	selectOnly(arg1: unknown): unknown;
    	setData(arg1: unknown): unknown;
    	setDragging(arg1: unknown): unknown;
    	setReadonly(arg1: unknown): unknown;
    	setState(arg1: unknown): unknown;
    	setViewport(arg1: unknown, arg2: unknown, arg3: unknown): unknown;
    	showCreationMenu(arg1: unknown, arg2: unknown, arg3: unknown): unknown;
    	showQuickSettingsMenu(arg1: unknown): unknown;
    	smartZoom(arg1: unknown): unknown;
    	snapDistance?: unknown;
    	staleSelection: null;
    	takeScreenshot(arg1: unknown, arg2: unknown): Promise<unknown>;
    	toggleGridSnapping(arg1: unknown): unknown;
    	toggleObjectSnapping(arg1: unknown): unknown;
    	toggleSelect(arg1: unknown): unknown;
    	tx: number;
    	ty: number;
    	tZoom: number;
    	undo(): unknown;
    	undoBtnEl: HTMLDivElement;
    	unload(): unknown;
    	updateFileOpen(arg1: unknown): unknown;
    	updateHistoryUI(): unknown;
    	updateSelection(arg1: unknown): unknown;
    	view: CanvasView;
    	viewportChanged: boolean;
    	virtualize(): unknown;
    	wasAnimating: boolean;
    	wrapperEl: HTMLDivElement;
    	x: number;
    	y: number;
    	zIndexCounter: number;
    	zoom: number;
    	zoomBreakpoint?: unknown;
    	zoomBy(arg1: unknown, arg2: unknown): unknown;
    	zoomCenter: null;
    	zoomToBbox(arg1: unknown): unknown;
    	zoomToFit(): unknown;
    	zoomToFitQueued: boolean;
    	zoomToSelection(): unknown;
}

// @public
export interface CanvasViewCanvasEdge {
    	attach(): unknown;
    	bbox: BBox;
    	bezier: Bezier;
    	blur(): unknown;
    	canvas: CanvasViewCanvas;
    	color: string;
    	createEdgeEnd(arg1: unknown): unknown;
    	deselect(): unknown;
    	destroy(): unknown;
    	detach(): unknown;
    	editLabel(): unknown;
    	focus(): unknown;
    	from: CanvasViewCanvasEdgeLink;
    	fromLineEnd: CanvasViewCanvasEdgeLineEnd | null;
    	getBBox(): unknown;
    	getCenter(): unknown;
    	getData(): unknown;
    	id: string;
    	initialize(): unknown;
    	initialized: boolean;
    	isAttached?: unknown;
    	label: string;
    	lineEndGroupEl: SVGGElement;
    	lineGroupEl: SVGGElement;
    	onClick(arg1: unknown): unknown;
    	onConnectionPointerdown(arg1: unknown): unknown;
    	onContextMenu(arg1: unknown): unknown;
    	path: CanvasViewCanvasEdgePath;
    	render(): unknown;
    	select(): unknown;
    	setColor(arg1: unknown, arg2: unknown): unknown;
    	setData(arg1: unknown): unknown;
    	setLabel(arg1: unknown): unknown;
    	showMenu(arg1: unknown, arg2: unknown): unknown;
    	to: CanvasViewCanvasEdgeLink;
    	toLineEnd: CanvasViewCanvasEdgeLineEnd | null;
    	unknownData: Object;
    	update(arg1: unknown, arg2: unknown): unknown;
    	updatePath(): unknown;
}

// @public
export interface CanvasViewCanvasEdgeLineEnd {
    	el: SVGGElement;
    	type: string;
}

// @public
export interface CanvasViewCanvasEdgeLink {
    	end: string;
    	node: CanvasViewCanvasNode;
    	side: string;
}

// @public
export interface CanvasViewCanvasEdgePath {
    	display: SVGPathElement;
    	interaction: SVGPathElement;
}

// @public
export interface CanvasViewCanvasNode extends CanvasViewCanvasNodeBase {
    	alwaysKeepLoaded: boolean;
    	app: App;
    	aspectRatio: number;
    	bbox: BBox;
    	blur(): unknown;
    	canvas: CanvasViewCanvas;
    	child: WidgetEditorView;
    	color: string;
    	containerEl: HTMLDivElement;
    	contentBlockerEl: HTMLDivElement;
    	contentEl: HTMLDivElement;
    	destroyed: boolean;
    	file: TFile;
    	filePath: string;
    	focus(): unknown;
    	getData(): unknown;
    	height: number;
    	id: string;
    	initFile(): unknown;
    	initialize(): unknown;
    	initialized: boolean;
    	isContentMounted: boolean;
    	isEditing: boolean;
    	nodeEl: HTMLDivElement;
    	onFileFocus(): unknown;
    	onLabelClick(arg1: unknown): unknown;
    	onLabelDblClick(arg1: unknown): unknown;
    	onPointerdown(arg1: unknown): unknown;
    	placeholderEl: HTMLDivElement;
    	render(): unknown;
    	renderedZIndex: number;
    	resizeDirty: boolean;
    	setData(arg1: unknown): unknown;
    	setFile(arg1: unknown, arg2: unknown, arg3: unknown): unknown;
    	setFilePath(arg1: unknown, arg2: unknown): unknown;
    	showMenu(arg1: unknown): unknown;
    	subpath: string;
    	unknownData: CanvasViewCanvasNodeUnknownData;
    	updateBreakpoint(arg1: unknown): unknown;
    	updateNodeLabel(arg1: unknown): unknown;
    	width: number;
    	x: number;
    	y: number;
    	zIndex: number;
}

// @public
export interface CanvasViewCanvasNodeBase extends CanvasViewCanvasNodeBaseBase {
    	blur(): unknown;
    	destroy(): unknown;
    	focus(): unknown;
    	initialize(): unknown;
    	isEditable(): unknown;
    	moveAndResize(arg1: unknown): unknown;
    	onClick(arg1: unknown): unknown;
    	onResizeDblclick(arg1: unknown, arg2: unknown): unknown;
    	render(): unknown;
    	startEditing(arg1?: unknown): unknown;
    	unloadChild(): unknown;
}

// @public
export interface CanvasViewCanvasNodeBaseBase extends CanvasViewCanvasNodeBaseBaseBase {
    	attach(): unknown;
    	detach(): unknown;
    	initialize(): unknown;
    	mountContent(): unknown;
    	preDetach(): unknown;
    	unmountContent(): unknown;
    	updateBreakpoint(arg1: unknown): unknown;
}

// @public
export interface CanvasViewCanvasNodeBaseBaseBase {
    	attach(): unknown;
    	blur(): unknown;
    	deselect(): unknown;
    	destroy(): unknown;
    	detach(): unknown;
    	focus(): unknown;
    	getBBox(): unknown;
    	getConnectedFiles(): unknown;
    	getData(): unknown;
    	initialize(): unknown;
    	isAttached?: unknown;
    	isEditable(): unknown;
    	isFocused?: unknown;
    	moveAndResize(arg1: unknown): unknown;
    	moveTo(arg1: unknown): unknown;
    	onClick(arg1: unknown): unknown;
    	onConnectionPointerdown(arg1: unknown, arg2: unknown): unknown;
    	onContextMenu(arg1: unknown): unknown;
    	onPointerdown(arg1: unknown): unknown;
    	onResizeDblclick(arg1: unknown, arg2: unknown): unknown;
    	onResizePointerdown(arg1: unknown, arg2: unknown): unknown;
    	preDetach(): unknown;
    	rect: CanvasRect;
    	render(): unknown;
    	renderZIndex(): unknown;
    	resize(arg1: unknown): unknown;
    	select(): unknown;
    	setColor(arg1: unknown, arg2: unknown): unknown;
    	setData(arg1: unknown): unknown;
    	setIsEditing(arg1: unknown): unknown;
    	showMenu(arg1: unknown): unknown;
    	startEditing(): unknown;
    	updateBreakpoint(arg1: unknown): unknown;
    	updateZIndex(): unknown;
}

// @public
export interface CanvasViewCanvasNodeUnknownData {
    	file: string;
    	id: string;
    	type: string;
}

// @public
export interface CanvasViewConfig {
    	defaultFileNodeDimensions: Dimensions;
    	defaultTextNodeDimensions: Dimensions;
    	minContainerDimension: number;
    	objectSnapDistance: number;
    	zoomMultiplier: number;
}

// @public
export interface CanvasViewConstructor extends TypedViewConstructor<CanvasView, [
	canvasPluginInstance: CanvasPluginInstance
]> {
}

// @public
export interface CanvasViewData {
    	edges: CanvasViewDataEdge[];
    	nodes: CanvasViewDataNode[];
}

// @public
export interface CanvasViewDataEdge {
    	fromNode: string;
    	fromSide: string;
    	id: string;
    	toNode: string;
    	toSide: string;
}

// @public
export interface CanvasViewDataNode {
    	file: string;
    	height: number;
    	id: string;
    	subpath?: unknown;
    	type: string;
    	width: number;
    	x: number;
    	y: number;
}

// @public
export interface CanvasViewHistory {
    	canRedo(): unknown;
    	canUndo(): unknown;
    	clear(): unknown;
    	current: number;
    	data: CanvasViewData[];
    	max: number;
    	push(arg1: unknown): unknown;
    	redo(): unknown;
    	replace(arg1: unknown): unknown;
    	undo(): unknown;
}

// @public
export interface CapacitorAdapterFs {
    	append(realPath: string, data: string): Promise<void>;
    	copy(realPath: string, newRealPath: string): Promise<void>;
    	delete(realPath: string): Promise<void>;
    	dir: string | null;
    	exists(realPath: string): Promise<boolean>;
    	getNativeUri(realPath: string): string;
    	getUri(realPath: string): string;
    	init(): Promise<void>;
    	mkdir(realPath: string): Promise<void>;
    	open(realPath: string): Promise<void>;
    	read(realPath: string): Promise<string>;
    	readBinary(realPath: string): Promise<ArrayBuffer>;
    	readdir(realPath: string): Promise<CapacitorFileEntry[]>;
    	rename(realPath: string, newRealPath: string): Promise<void>;
    	rmdir(realPath: string): Promise<void>;
    	setTimes(realPath: string, ctime: number, mtime: number): Promise<void>;
    	stat(realPath: string): Promise<CapacitorFileEntry>;
    	trash(realPath: string): Promise<void>;
    	uri: string;
    	verifyIcloud(realPath: string): Promise<void>;
    	watch(realPath: string): Promise<void>;
    	watchAndStatAll(realPath: string): Promise<{
        		children: CapacitorFileEntry[];
        	}>;
    	write(realPath: string, data: string): Promise<void>;
    	writeBinary(realPath: string, data: ArrayBuffer): Promise<void>;
    	writeBinaryInternal(realPath: string, data: ArrayBuffer): Promise<void>;
}

// @public
export type CapacitorAdapterFsConstructor = new (dir: string) => CapacitorAdapterFs;

// @public
export interface CapacitorFileEntry extends Partial<FileStats> {
    	name: string;
    	type: "file" | "directory";
    	uri: string;
}

// @public
export interface CeilFunction extends BasesFunction, HasGetDisplayName {
}

// @public
export interface CheckboxPropertyWidgetComponent extends PropertyWidgetComponentBase {
    	checkboxEl: HTMLInputElement;
    	type: "checkbox";
}

// @public
export interface ClickableToken {
    	end: EditorPosition;
    	start: EditorPosition;
    	text: string;
    	type: string;
}

// @public
export interface ClipboardManager {
    	app: App;
    	getPath(): string;
    	handleDataTransfer(data: DataTransfer): null | Promise<void>;
    	handleDragOver(event: DragEvent): void;
    	handleDrop(event: DragEvent): boolean;
    	handleDropIntoEditor(event: DragEvent): null | string;
    	handlePaste(event: ClipboardEvent): boolean;
    	info: MarkdownView;
    	insertAttachmentEmbed(file: TAbstractFile, replace: boolean): Promise<void>;
    	insertFiles(importedAttachments: ImportedAttachment[]): Promise<void>;
    	saveAttachment(name: string, extension: string, data: ArrayBuffer, replace: boolean): Promise<void>;
}

// @public
export type CodeBlockPostProcessorHandler = (source: string, el: HTMLElement, ctx: MarkdownPostProcessorContext) => Promise<void> | void;

// @public
export interface CodeMirrorAdapterEx {
    	new (cm6: VimEditor): CodeMirrorEditor;
    	addClass(element: HTMLElement, className: string): void;
    	commands: CodeMirrorAdapterExCommands;
    	defineOption(option: string, defaultValue: unknown, handler: () => void): void;
    	e_preventDefault(event: Event): void;
    	e_stop(event: Event): void;
    	findEnclosingTag(doc: CodeMirrorAdapterEx, pos: EditorPosition): EnclosingTag | undefined;
    	findMatchingTag(doc: CodeMirrorAdapterEx, pos: EditorPosition): void;
    	isMac: boolean;
    	isWordChar(char: string): boolean;
    	keyMap: Record<string, unknown>;
    	keyName(event: KeyboardEvent): string;
    	keys: Record<string, unknown>;
    	lookupKey(key: string, context: unknown, callback: (action: (codeMirrorAdapter: CodeMirrorAdapterEx) => boolean) => void): void;
    	off(event: string, listener: EventListenerOrEventListenerObject): void;
    	on(event: string, listener: EventListenerOrEventListenerObject): void;
    	Pos: new (line: number, ch: number) => EditorPosition;
    	rmClass(element: HTMLElement, className: string): void;
    	signal(target: unknown, type: string, ...values: unknown[]): void;
    	StringStream: unknown;
    	Vim: VimApi;
    	vimKey(event: KeyboardEvent): string;
}

// @public
export interface CodeMirrorAdapterExCommands {
    	cursorCharLeft(editor: CodeMirrorEditor): void;
    	indentAuto(editor: CodeMirrorEditor): void;
    	newlineAndIndent(editor: CodeMirrorEditor): void;
    	newlineAndIndentBefore(editor: CodeMirrorEditor): void;
    	redo(editor: CodeMirrorEditor): void;
    	undo(editor: CodeMirrorEditor): void;
}

// @public
export interface CodeMirrorEditor {
    	$lineHandleChanges: LineHandleChange[] | undefined;
    	addOverlay(options: AddOverlayOptions): SearchQuery | undefined;
    	blur(): void;
    	charCoords(pos: EditorPosition, mode: "local" | "page" | "window" | "div"): Coords;
    	clipPos(pos: EditorPosition): EditorPosition;
    	coordsChar(coords: Coords, mode: "local" | "page" | "window" | "div"): EditorPosition;
    	defaultTextHeight(): number;
    	destroy(): void;
    	execCommand(command: string): void;
    	findMatchingBracket(pos: EditorPosition): MatchingBracket;
    	findPosV(start: EditorPosition, amount: number, unit: "line" | "page", goalColumn: number): EditorPosition;
    	firstLine(): number;
    	focus(): void;
    	foldCode(line: number): void;
    	forEachSelection(fn: () => void): void;
    	getCursor(type?: "head" | "anchor" | "start" | "end"): EditorPosition;
    	getInputField(): HTMLElement;
    	getLastEditEnd(): EditorPosition;
    	getLine(line: number): string;
    	getLineHandle(line: number): LineHandle;
    	getLineNumber(handle: LineHandle): number | null;
    	getMainSelection(): EditorSelection;
    	getMode(): CodeMirrorEditorMode;
    	getOption(option: string): unknown;
    	getRange(from: EditorPosition, to: EditorPosition): string;
    	getScrollInfo(): ScrollInfo;
    	getSearchCursor(query: RegExp, pos: EditorPosition): CodeMirrorEditorSearchCursor;
    	getSelection(): string;
    	getSelections(): string[];
    	getTokenTypeAt(pos: EditorPosition): string;
    	getValue(): string;
    	getWrapperElement(): HTMLElement;
    	hardWrap(options: HardWrapOptions): void;
    	indentLess(): void;
    	indentLine(line: number, more?: boolean): void;
    	indentMore(): void;
    	indexFromPos(pos: EditorPosition): number;
    	isInMultiSelectMode(): boolean;
    	lastLine(): number;
    	lineCount(): number;
    	listSelections(): Array<{
        		anchor: EditorPosition;
        		head: EditorPosition;
        	}>;
    	moveByChar(pos: EditorPosition, dir: "left" | "right", unit: number): EditorPosition;
    	moveH(dir: number, unit: string): void;
    	off(event: string, listener: EventListenerOrEventListenerObject): void;
    	on(event: string, listener: EventListenerOrEventListenerObject): void;
    	onBeforeEndOperation(): void;
    	onChange(lineHandleChange: LineHandleChange): void;
    	onSelectionChange(): void;
    	openDialog(template: string, keyValidator: (keyValue: string) => boolean, options?: Partial<OpenDialogOptions>): void;
    	openNotification(message: string, options?: OpenNotificationOptions): () => void;
    	operation<T>(fn: () => T): T;
    	overWriteSelection(text: string): void;
    	posFromIndex(index: number): EditorPosition;
    	refresh(): void;
    	releaseLineHandles(): void;
    	removeOverlay(overlay?: SearchQuery): void;
    	replaceRange(text: string, from: EditorPosition, to?: EditorPosition): void;
    	replaceSelection(text: string): void;
    	replaceSelections(texts: string[]): void;
    	scanForBracket(from: EditorPosition, direction: number, style?: string): Bracket | null;
    	scrollInfo(): ScrollInfo;
    	scrollIntoView(pos?: EditorPosition, margin?: number): void;
    	scrollTo(x?: number, y?: number): void;
    	setBookmark(pos: EditorPosition, options?: SetBookmarkOptions): Bookmark;
    	setCursor(line: number, ch: number): void;
    	setOption(option: string, value: unknown): void;
    	setSelection(anchor: EditorPosition, head: EditorPosition, options?: SetSelectionOptions): void;
    	setSelections(selections: EditorSelection[], primaryIndex?: number): void;
    	setSize(width: number, height: number): void;
    	setValue(content: string): void;
    	signal(event: string, ...args: unknown[]): void;
    	somethingSelected(): boolean;
    	toggleOverwrite(overwrite: boolean): void;
    	virtualSelectionMode(): boolean;
}

// @public
export interface CodeMirrorEditorMode {
    	name: string;
}

// @public
export interface CodeMirrorEditorSearchCursor {
    	find(reverse?: boolean): boolean;
    	findNext(): boolean;
    	findPrevious(): boolean;
    	from(): EditorPosition | void;
    	replace(text: string): void;
    	to(): EditorPosition | void;
}

// @public
export interface CommandPaletteModal extends FuzzySuggestModal<Command> {
    	commands: Command[] | null;
    	plugin: CommandPalettePluginInstance;
}

// @public
export interface CommandPaletteOptions {
    	pinned: string[];
}

// @public
export interface CommandPalettePlugin extends InternalPlugin<CommandPalettePluginInstance> {
}

// @public
export interface CommandPalettePluginInstance extends InternalPluginInstance<CommandPalettePlugin> {
    	app: App;
    	defaultOn: true;
    	getCommands(): Command[];
    	modal: CommandPaletteModal;
    	onExternalSettingsChange(): Promise<void>;
    	onOpen(): boolean;
    	openCallback(): boolean;
    	options: CommandPaletteOptions;
    	plugin: CommandPalettePlugin;
    	recentCommands: string[];
    	saveSettings(plugin: CommandPalettePlugin): void;
}

// @public
export interface Commands {
    	addCommand(command: Command): void;
    	app: App;
    	commands: CommandsCommandsRecord;
    	editorCommands: CommandsEditorCommandsRecord;
    	executeCommand(command: Command): boolean;
    	executeCommandById(commandId: string): boolean;
    	findCommand(commandId: string): Command | undefined;
    	listCommands(): Command[];
    	removeCommand(commandId: string): void;
}

// @public
export interface CommandsCommandsRecord extends Record<string, Command> {
}

// @public
export interface CommandsEditorCommandsRecord extends Record<string, Command> {
}

// @public
export interface ConcatFunction extends BasesFunction {
}

// @public
export type ConfigItem = "accentColor" | "alwaysUpdateLinks" | "attachmentFolderPath" | "autoConvertHtml" | "autoPairBrackets" | "autoPairMarkdown" | "baseFontSize" | "baseFontSizeAction" | "cssTheme" | "defaultViewMode" | "enabledCssSnippets" | "focusNewTab" | "foldHeading" | "foldIndent" | "hotkeys" | "interfaceFontFamily" | "livePreview" | "mobilePullAction" | "mobileQuickRibbonItem" | "mobileToolbarCommands" | "monospaceFontFamily" | "nativeMenus" | "newFileFolderPath" | "newFileLocation" | "newLinkFormat" | "pdfExportSettings" | "promptDelete" | "propertiesInDocument" | "readableLineLength" | "rightToLeft" | "showIndentGuide" | "showInlineTitle" | "showLineNumber" | "showRibbon" | "showUnsupportedFiles" | "showViewHeader" | "smartIndentList" | "spellcheck" | "spellcheckLanguages" | "strictLineBreaks" | "tabSize" | "textFontFamily" | "theme" | "translucency" | "trashOption" | "types" | "uriCallbacks" | "useMarkdownLinks" | "useTab" | "userIgnoreFilters" | "vimMode";

// @public
export interface ConstructorBase<Args extends unknown[], Instance> {
    	new (...args: Args): Instance;
    	prototype: Instance;
}

// @public
export interface ContainsAllFunction extends BasesFunction, HasGetDisplayName, HasGetRHSWidgetType {
}

// @public
export interface ContainsAnyFunction extends BasesFunction, HasGetDisplayName, HasGetRHSWidgetType {
}

// @public
export interface ContainsFunction extends BasesFunction, HasGetDisplayName, HasGetRHSWidgetType {
}

// @public
export interface ContainsNoneFunction extends BasesFunction, HasGetDisplayName, HasGetRHSWidgetType {
}

// @public
export type ContentPosition = [
	startOffset: number,
	endOffset: number
];

// @public
export interface Coords {
    	bottom: number;
    	left: number;
    	right: number;
    	top: number;
}

// @public
export interface CoordsLeftTop {
    	left: number;
    	top: number;
}

// @public
export function createTFileInstance(app: App, path: string): TFile;

// @public
export function createTFolderInstance(app: App, path: string): TFolder;

// @public
export interface CustomArrayDict<T> {
    	add(key: string, value: T): void;
    	clear(key: string): void;
    	clearAll(): void;
    	contains(key: string, value: T): boolean;
    	count(): number;
    	data: Map<string, T[]>;
    	get(key: string): T[] | null;
    	keys(): string[];
    	remove(key: string, value: T): void;
}

// @public
export class CustomArrayDictImpl<T> implements CustomArrayDict<T> {
    	// (undocumented)
    add(key: string, value: T): void;
    	// (undocumented)
    clear(key: string): void;
    	// (undocumented)
    clearAll(): void;
    	// (undocumented)
    contains(key: string, value: T): boolean;
    	// (undocumented)
    count(): number;
    	// (undocumented)
    data: Map<string, T[]>;
    	// (undocumented)
    get(key: string): T[] | null;
    	// (undocumented)
    keys(): string[];
    	// (undocumented)
    remove(key: string, value: T): void;
}

// @public
export interface CustomCSS extends Component {
    	app: App;
    	boundRaw(themeName: string): void;
    	checkForUpdate(themeName: string): void;
    	checkForUpdates(): void;
    	csscache: Map<string, string>;
    	disableTranslucency(): void;
    	downloadLegacyTheme(options: DownloadLegacyThemeOptions): Promise<string>;
    	enabledSnippets: Set<string>;
    	enableTranslucency(): void;
    	extraStyleEls: HTMLStyleElement[];
    	getManifest(repoUrl: string): Promise<ThemeManifest>;
    	getSnippetPath(snippetName: string): string;
    	getSnippetsFolder(): string;
    	getThemeFolder(): string;
    	getThemePath(themeName: string): string;
    	hasUpdates(): boolean;
    	installLegacyTheme(options: InstallThemeOptions): Promise<void>;
    	installTheme(options: InstallThemeOptions, version: string): Promise<void>;
    	isThemeInstalled(themeName: string): boolean;
    	loadCss(arg1: unknown): Promise<unknown>;
    	loadData(): unknown;
    	loadSnippets(): unknown;
    	loadTheme(arg1: unknown): unknown;
    	oldThemes: string[];
    	onload(): void;
    	onRaw(themeName: string): void;
    	queue: PromisedQueue;
    	readSnippets(): void;
    	readThemes(): void;
    	removeTheme(themeName: string): Promise<void>;
    	requestLoadSnippets: Debouncer<[
    	], void>;
    	requestLoadTheme: Debouncer<[
    	], void>;
    	requestReadThemes: Debouncer<[
    	], void>;
    	setCssEnabledStatus(snippetName: string, enabled: boolean): void;
    	setTheme(themeName: string): void;
    	setTranslucency(translucency: boolean): void;
    	snippets: string[];
    	theme: "" | string;
    	themes: CustomCSSThemesRecord;
    	updates: CustomCSSUpdatesRecord;
}

// @public
export interface CustomCSSThemesRecord extends Record<string, ThemeManifest> {
}

// @public
export interface CustomCSSUpdatesRecord extends Record<string, unknown> {
}

// @public
export interface DailyNotesOptions {
    	autorun?: boolean;
    	folder?: string;
    	format?: string;
    	template?: string;
}

// @public
export interface DailyNotesPlugin extends InternalPlugin<DailyNotesPluginInstance> {
}

// @public
export interface DailyNotesPluginInstance extends InternalPluginInstance<DailyNotesPlugin> {
    	app: App;
    	defaultOn: true;
    	getCurrentFileDateTimestamp(): null | number;
    	getDailyNote(date: typeof default_2): Promise<TFile | null | undefined>;
    	getFormat(): string;
    	gotoNextExisting(timestamp: number): Promise<void>;
    	gotoPreviousExisting(timestamp: number): Promise<void>;
    	iterateDailyNotes(callback: (file: TFile, timestamp: number) => void): void;
    	onExternalSettingsChange(): Promise<void>;
    	onOpenDailyNote(evt: Event): Promise<void>;
    	options: DailyNotesOptions;
    	plugin: DailyNotesPlugin;
}

// @public
export interface DataAdapterFilesRecord extends Record<string, FileEntry> {
}

// @public
export interface DataAdapterWatchersRecord extends Record<string, DataAdapterWatchersRecordEntry> {
}

// @public
export interface DataAdapterWatchersRecordEntry {
    	resolvedPath: string;
    	watcher: FSWatcher;
}

// @public
export interface Database {
    	changeVersion(oldVersion: string, newVersion: string, callback?: (transaction: SQLTransaction) => void, errorCallback?: (error: SQLError) => void, successCallback?: () => void): void;
    	readTransaction(callback: (transaction: SQLTransaction) => void, errorCallback?: (error: SQLError) => void, successCallback?: () => void): void;
    	transaction(callback: (transaction: SQLTransaction) => void, errorCallback?: (error: SQLError) => void, successCallback?: () => void): void;
    	version: string;
}

// @public
export interface DateAfterFunction extends BasesFunction, HasGetDisplayName, HasCompare, HasGetRHSWidgetType {
}

// @public
export interface DateBeforeFunction extends BasesFunction, HasGetDisplayName, HasCompare, HasGetRHSWidgetType {
}

// @public
export interface DateDiffFunction extends BasesFunction {
}

// @public
export interface DateEqualsFunction extends BasesFunction, HasGetDisplayName, HasCompare, HasGetRHSWidgetType {
}

// @public
export interface DateModifyFunction extends BasesFunction {
}

// @public
export interface DateNotEqualsFunction extends BasesFunction, HasGetDisplayName, HasCompare, HasGetRHSWidgetType {
}

// @public
export interface DateOnOrAfterFunction extends BasesFunction, HasGetDisplayName, HasCompare, HasGetRHSWidgetType {
}

// @public
export interface DateOnOrBeforeFunction extends BasesFunction, HasGetDisplayName, HasCompare, HasGetRHSWidgetType {
}

// @public
export interface DatePropertyWidgetComponent extends DatePropertyWidgetComponentBase {
    	buttonEl: HTMLDivElement | null;
    	type: "date";
}

// @public
export interface DatePropertyWidgetComponentBase extends PropertyWidgetComponentBase {
    	buildInput(parentEl: HTMLElement): HTMLInputElement;
    	date?: default_2.Moment;
    	dirty: boolean;
    	format(input: default_2.Moment): string;
    	hoverPopup: HoverPopover | null;
    	inputEl: HTMLInputElement;
    	parse(input: default_2.MomentInput): void;
    	value: string;
}

// @public
export interface DatetimePropertyWidgetComponent extends DatePropertyWidgetComponentBase {
    	type: "datetime";
}

// @public
export interface DayFunction extends BasesFunction, HasExtract {
}

// @public
export interface DeferredView extends View {
}

// @public
export interface Dimensions {
    	height: number;
    	width: number;
}

// @public
export interface DownloadLegacyThemeOptions {
    	repo: string;
}

// @public
export interface Draggable {
    	file?: TAbstractFile;
    	files?: TAbstractFile[];
    	icon: string;
    	linktext?: string;
    	source?: unknown;
    	sourcePath?: string;
    	title: string;
    	type: string;
}

// @public
export interface DragManager {
    	actionEl: HTMLElement | null;
    	app: App;
    	dragFile(event: DragEvent, file: TFile, source?: unknown): Draggable;
    	dragFiles(event: DragEvent, files: TAbstractFile[], source?: unknown): Draggable | null;
    	dragFolder(event: DragEvent, folder: TFolder, source?: unknown): Draggable;
    	draggable: Draggable | null;
    	dragLink(event: DragEvent, linkText: string, sourcePath: string, title?: string, source?: unknown): Draggable;
    	dragStart: DragStartEvent | null;
    	ghostEl: HTMLElement | null;
    	handleDrag(el: HTMLElement, draggableGetter: (event: DragEvent) => Draggable | null): void;
    	handleDrop(el: HTMLElement, dropHandler: (event: DragEvent, draggable: Draggable, isOver: boolean) => DropResult | null, draggable?: boolean): void;
    	hideOverlay(): void;
    	hoverClass: string;
    	hoverEl: HTMLElement | null;
    	isDragOverHandled: boolean;
    	onDragEnd(): void;
    	onDragLeave(event: DragEvent): void;
    	onDragOver(event: DragEvent): void;
    	onDragOverFirst(): void;
    	onDragStart(event: DragEvent, draggable: Draggable): void;
    	onDragStartGlobal(event: DragEvent): void;
    	onTouchEnd(event: TouchEvent): void;
    	overlayEl: HTMLElement;
    	removeOverlay(): void;
    	setAction(action: string | null): void;
    	shouldHideOverlay: boolean;
    	showOverlay(doc: Document, rect: DOMRect): void;
    	sourceClass: string;
    	sourceEls: HTMLElement[] | null;
    	updateHover(hoverEl: HTMLElement | null, hoverClass: string): void;
    	updateSource(sourceEls: HTMLElement[] | null, sourceClass: string): void;
}

// @public
export interface DragStartEvent {
    	evt: DragEvent;
    	moved: boolean;
}

// @public
export interface DropResult {
    	action: string | null;
    	dropEffect: "none" | "copy" | "link" | "move";
    	hoverClass?: string;
    	hoverEl?: HTMLElement | null;
}

// @public
export interface EdgeIndex extends EdgeIndexBase {
    	compareMinX(arg1: unknown, arg2: unknown): unknown;
    	compareMinY(arg1: unknown, arg2: unknown): unknown;
    	data: EdgeIndexData;
    	_maxEntries: number;
    	_minEntries: number;
}

// @public
export interface EdgeIndexBase extends EdgeIndexBaseBase {
    	insert(arg1: unknown): unknown;
    	remove(arg1: unknown): unknown;
    	toBBox(arg1: unknown): unknown;
}

// @public
export interface EdgeIndexBaseBase {
    	_adjustParentBBoxes(arg1: unknown, arg2: unknown, arg3: unknown): unknown;
    	all(): unknown;
    	_all(arg1: unknown, arg2: unknown): unknown;
    	_allDistMargin(arg1: unknown, arg2: unknown, arg3: unknown, arg4: unknown): unknown;
    	_build(arg1: unknown, arg2: unknown, arg3: unknown, arg4: unknown): unknown;
    	_chooseSplitAxis(arg1: unknown, arg2: unknown, arg3: unknown): unknown;
    	_chooseSplitIndex(arg1: unknown, arg2: unknown, arg3: unknown): unknown;
    	_chooseSubtree(arg1: unknown, arg2: unknown, arg3: unknown, arg4: unknown): unknown;
    	clear(): unknown;
    	collides(arg1: unknown): unknown;
    	compareMinX(arg1: unknown, arg2: unknown): unknown;
    	compareMinY(arg1: unknown, arg2: unknown): unknown;
    	_condense(arg1: unknown): unknown;
    	fromJSON(arg1: unknown): unknown;
    	insert(arg1: unknown): unknown;
    	_insert(arg1: unknown, arg2: unknown, arg3: unknown): unknown;
    	load(arg1: unknown): unknown;
    	remove(arg1: unknown, arg2: unknown): unknown;
    	search(arg1: unknown): unknown;
    	_split(arg1: unknown, arg2: unknown): unknown;
    	_splitRoot(arg1: unknown, arg2: unknown): unknown;
    	toBBox(arg1: unknown): unknown;
    	toJSON(): unknown;
}

// @public
export interface EdgeIndexData {
    	children: CanvasViewCanvasEdge[];
    	height: number;
    	leaf: boolean;
    	maxX: number;
    	maxY: number;
    	minX: number;
    	minY: number;
}

// @public
export interface EditorLanguageSupport {
}

// @public
export interface EditorRangeEx {
    	from: EditorPosition | null;
    	to: EditorPosition | null;
}

// @public
export interface EditorSearchComponent extends AbstractSearchComponent {
    	clear(): void;
    	cursor: null | SearchCursor;
    	editor: Editor;
    	findNext(): void;
    	findNextOrReplace(): void;
    	findPrevious(): void;
    	hide(): void;
    	highlight(ranges: EditorRange[]): void;
    	isActive: boolean;
    	isReplace: boolean;
    	onAltEnter(e?: KeyboardEvent): void;
    	onModAltEnter(e?: KeyboardEvent): void;
    	onSearchInput(): void;
    	replaceAll(): void;
    	replaceCurrentMatch(): void;
    	searchAll(): void;
    	show(replace: boolean): void;
}

// @public
export interface EditorSelection {
    	anchor: EditorPosition;
    	head: EditorPosition;
}

// @public
export interface EditorStatusPlugin extends InternalPlugin<EditorStatusPluginInstance> {
}

// @public
export interface EditorStatusPluginInstance extends InternalPluginInstance<EditorStatusPlugin> {
    	app: App;
    	defaultOn: true;
    	hiddenFromList: true;
    	plugin: EditorStatusPlugin;
}

// @public
export interface EditorSuggestEx {
    	currentSuggest?: EditorSuggest<unknown>;
    	suggests: EditorSuggest<unknown>[];
}

// @public
export interface EditorSuggests {
    	addSuggest(suggest: EditorSuggest<unknown>): void;
    	close(): void;
    	currentSuggest: null | EditorSuggest<unknown>;
    	isShowingSuggestion(): boolean;
    	removeSuggest(suggest: EditorSuggest<unknown>): void;
    	reposition(): void;
    	setCurrentSuggest(suggest: EditorSuggest<unknown>): void;
    	suggests: EditorSuggest<unknown>[];
    	trigger(editor: MarkdownBaseView, t: TFile, n: boolean): void;
}

// @public
export interface EditorViewState {
    	printing: boolean;
}

// @public
export interface ElectronWindow extends BrowserWindow {
    	_browserViews: unknown;
    	devToolsWebContents: unknown;
    	_events: unknown;
    	_eventsCount: unknown;
}

// @public
export interface EmbedAudioComponent extends EmbedComponent {
}

// @public
export interface EmbedCanvasComponent extends EmbedComponent {
}

// @public
export interface EmbedComponent extends Component {
    	loadFile(): void;
}

// @public
export interface EmbedContext {
    	app: App;
    	containerEl: HTMLElement;
    	depth?: number;
    	displayMode?: boolean;
    	linktext?: string;
    	showInline?: boolean;
    	sourcePath?: string;
    	state?: unknown;
}

// @public
export type EmbedCreator = (context: EmbedContext, file: TFile, subpath?: string) => EmbedComponent;

// @public
export interface EmbeddedEditorView extends Component {
    	app: App;
    	containerEl: HTMLElement;
    	destroyEditor(save?: boolean): void;
    	dirty: boolean;
    	editable: boolean;
    	editMode?: IFramedMarkdownEditor | undefined;
    	get editor(): IFramedMarkdownEditor | null;
    	editorEl: HTMLElement;
    	file: null | TFile;
    	getMode(): "source" | "preview";
    	hoverPopover: null | HoverPopover;
    	onload(): void;
    	onMarkdownScroll(): void;
    	onunload(): void;
    	get path(): string;
    	previewEl: HTMLElement;
    	previewMode: MarkdownPreviewView;
    	requestSave(): void;
    	requestSaveFolds(): void;
    	save(data: string, save?: boolean): void;
    	get scroll(): unknown;
    	set(data: string, clear: boolean): void;
    	showEditor(): void;
    	showPreview(save?: boolean): void;
    	showSearch(replace?: boolean): void;
    	state: unknown;
    	text: string;
    	toggleMode(): void;
    	useIframe: boolean;
}

// @public
export interface EmbedImageComponent extends EmbedComponent {
}

// @public
export interface EmbedMarkdownComponent extends EmbedComponent {
}

// @public
export interface EmbedPdfComponent extends EmbedComponent {
}

// @public
export interface EmbedRegistry extends Events {
    	embedByExtension: EmbedRegistryEmbedByExtensionRecord;
    	getEmbedCreator(file: TFile): EmbedCreator | null;
    	isExtensionRegistered(extension: string): boolean;
    	registerExtension(extension: string, embedCreator: EmbedCreator): void;
    	registerExtensions(extensions: string[], embedCreator: EmbedCreator): void;
    	unregisterExtension(extension: string): void;
    	unregisterExtensions(extensions: string[]): void;
}

// @public
export interface EmbedRegistryEmbedByExtensionRecord extends Record<string, EmbedCreator> {
    	[FileExtension._3gp]: (context: EmbedContext, file: TFile) => EmbedAudioComponent;
    	[FileExtension.avif]: (context: EmbedContext, file: TFile) => EmbedImageComponent;
    	[FileExtension.bmp]: (context: EmbedContext, file: TFile) => EmbedImageComponent;
    	[FileExtension.canvas]: (context: EmbedContext, file: TFile, subpath?: string) => EmbedCanvasComponent;
    	[FileExtension.flac]: (context: EmbedContext, file: TFile) => EmbedAudioComponent;
    	[FileExtension.gif]: (context: EmbedContext, file: TFile) => EmbedImageComponent;
    	[FileExtension.jpeg]: (context: EmbedContext, file: TFile) => EmbedImageComponent;
    	[FileExtension.jpg]: (context: EmbedContext, file: TFile) => EmbedImageComponent;
    	[FileExtension.m4a]: (context: EmbedContext, file: TFile) => EmbedAudioComponent;
    	[FileExtension.md]: (context: EmbedContext, file: TFile, subpath?: string) => EmbedMarkdownComponent;
    	[FileExtension.mkv]: (context: EmbedContext, file: TFile) => EmbedVideoComponent;
    	[FileExtension.mov]: (context: EmbedContext, file: TFile) => EmbedVideoComponent;
    	[FileExtension.mp3]: (context: EmbedContext, file: TFile) => EmbedAudioComponent;
    	[FileExtension.mp4]: (context: EmbedContext, file: TFile) => EmbedVideoComponent;
    	[FileExtension.oga]: (context: EmbedContext, file: TFile) => EmbedAudioComponent;
    	[FileExtension.ogg]: (context: EmbedContext, file: TFile) => EmbedAudioComponent;
    	[FileExtension.ogv]: (context: EmbedContext, file: TFile) => EmbedVideoComponent;
    	[FileExtension.opus]: (context: EmbedContext, file: TFile) => EmbedAudioComponent;
    	[FileExtension.pdf]: (context: EmbedContext, file: TFile, subpath?: string) => EmbedPdfComponent;
    	[FileExtension.png]: (context: EmbedContext, file: TFile) => EmbedImageComponent;
    	[FileExtension.svg]: (context: EmbedContext, file: TFile) => EmbedImageComponent;
    	[FileExtension.wav]: (context: EmbedContext, file: TFile) => EmbedAudioComponent;
    	[FileExtension.webm]: (context: EmbedContext, file: TFile) => EmbedVideoComponent;
    	[FileExtension.webp]: (context: EmbedContext, file: TFile) => EmbedImageComponent;
}

// @public
export interface EmbedVideoComponent extends EmbedComponent {
}

// @public
export interface EmptyFunction extends BasesFunction, HasGetDisplayName, HasGetRHSWidgetType {
}

// @public
export interface EmptyView extends ItemView {
    	getViewType(): typeof ViewType.Empty;
}

// @public
export interface EmptyViewConstructor extends TypedViewConstructor<EmptyView> {
}

// @public
export interface EnclosingTag {
    	close: EditorRangeEx;
    	open: EditorRangeEx;
}

// @public
export interface EnsureSideLeafOptions {
    	// (undocumented)
    active?: boolean;
    	// (undocumented)
    reveal?: boolean;
    	// (undocumented)
    split?: boolean;
    	// (undocumented)
    state?: any;
}

// @public
export interface EqualFunction extends BasesFunction, HasGetDisplayName, HasCompare, HasGetRHSWidgetType {
}

// @public
export interface EventsEntry {
    	ctx: unknown;
    	e: Events;
    	fn(...data: unknown[]): unknown;
    	name: string;
}

// @public
export interface ExtendedMetrics {
    	containerWidth: number;
    	em: number;
    	ex: number;
    	family: string;
    	lineWidth: number;
    	scale: number;
}

// @public
export interface FileBookmarkItem extends BookmarkItem {
    	path: string;
    	subpath: string;
    	type: "file";
}

// @public
export interface FileCacheEntry {
    	hash: string;
    	mtime: number;
    	size: number;
}

// @public
export interface FileEntry extends Partial<FileStats> {
    	name?: string;
    	realpath: string;
    	type: "file" | "folder";
    	uri?: string;
}

// @public
export interface FileExplorerPlugin extends InternalPlugin<FileExplorerPluginInstance> {
    	revealInFolder(item: TFile | TFolder): void;
}

// @public
export interface FileExplorerPluginInstance extends InternalPluginInstance<FileExplorerPlugin> {
    	app: App;
    	defaultOn: true;
    	plugin: FileExplorerPlugin;
    	revealInFolder(item: TFile | TFolder): void;
}

// @public
export interface FileExplorerView extends View {
    	acceptRename(): Promise<void>;
    	afterCreate(file: TFile, newLeaf: PaneType | boolean): Promise<void>;
    	attachDropHandler(folder: TFolder, el: HTMLElement): void;
    	attachFileEvents(e: unknown): void;
    	createAbstractFile(type: "file" | "folder", location: TFolder, newLeaf: PaneType | boolean): Promise<void>;
    	createFolderDom(folder: TFolder): unknown;
    	createItemDom(file: TFile): unknown;
    	displayError(message: string, fileItem: unknown): void;
    	dragFiles(event: DragEvent, t: unknown): unknown;
    	exitRename(): void;
    	fileItems: FileExplorerViewFileItemsRecord;
    	files: WeakMapWrapper<HTMLElement, TAbstractFile>;
    	getNodeId(e: unknown): unknown;
    	getSortedFolderItems(folder: TFolder): FileTreeItem[];
    	getViewType(): typeof ViewType.FileExplorer;
    	isItem(item: unknown): boolean;
    	lastDropTargetEl: HTMLElement | null;
    	mouseoverExpandTimeout: number | null;
    	onCreate(file: TAbstractFile): void;
    	onCreateNewFolderClick(event: MouseEvent): Promise<void>;
    	onCreateNewNoteClick(event: MouseEvent): Promise<void>;
    	onDelete(file: TAbstractFile): void;
    	onDeleteSelectedFiles(event: unknown): unknown;
    	onExtensionsUpdated(): void;
    	onFileMouseout(event: MouseEvent, targetEl: HTMLElement): void;
    	onFileMouseover(event: MouseEvent, targetEl: HTMLElement): void;
    	onFileOpen(file: TFile): void;
    	onFileRenameInput(e: unknown): void;
    	onKeyEnterInRename(event: KeyboardEvent): void;
    	onKeyEscInRename(): void;
    	onKeyRename(event: KeyboardEvent): void;
    	onModify(): void;
    	onRename(file: TAbstractFile, oldPath: string): void;
    	onTitleBlur(): void;
    	openFileContextMenu(event: Event, fileItemEl: HTMLElement): void;
    	ready: boolean;
    	requestSort: Debouncer<[
    	], void>;
    	revealInFolder(file: TFile | TFolder): void;
    	setIsAllCollapsed(e: unknown): void;
    	setSortOrder(order: unknown): void;
    	sort(): void;
    	sortOrder: FileExplorerViewSortOrder;
    	startRenameFile(e: unknown): unknown;
    	tree: Tree<FileTreeItem | FolderTreeItem>;
    	updateConfig(): void;
}

// @public
export interface FileExplorerViewConstructor extends TypedViewConstructor<FileExplorerView> {
}

// @public
export interface FileExplorerViewFileItemsRecord extends Record<string, FileTreeItem | FolderTreeItem> {
}

// @public
export type FileExplorerViewSortOrder = "alphabetical" | "alphabeticalReverse" | "byCreatedTime" | "byCreatedTimeReverse" | "byModifiedTime" | "byModifiedTimeReverse";

// @public
export const FileExtension: {
    	readonly _3gp: "3gp";
    	readonly avif: "avif";
    	readonly bmp: "bmp";
    	readonly canvas: "canvas";
    	readonly flac: "flac";
    	readonly gif: "gif";
    	readonly jpeg: "jpeg";
    	readonly jpg: "jpg";
    	readonly m4a: "m4a";
    	readonly md: "md";
    	readonly mkv: "mkv";
    	readonly mov: "mov";
    	readonly mp3: "mp3";
    	readonly mp4: "mp4";
    	readonly oga: "oga";
    	readonly ogg: "ogg";
    	readonly ogv: "ogv";
    	readonly opus: "opus";
    	readonly pdf: "pdf";
    	readonly png: "png";
    	readonly svg: "svg";
    	readonly wav: "wav";
    	readonly webm: "webm";
    	readonly webp: "webp";
};

// @public
export interface FilePropertiesView extends InfoFileView {
    	getFile(): TFile;
    	getViewType(): typeof ViewType.FileProperties;
    	isSupportedFile(file: TFile): boolean;
    	onFileChange(file: TFile): Promise<unknown>;
    	onQuickPreview(file: TFile, t: unknown): void;
    	readSupportedFile(file: TFile): Promise<unknown>;
    	saveFrontmatter(e: unknown): void;
    	shiftFocusAfter(): void;
    	shiftFocusBefore(): void;
    	update(): void;
    	updateEmptyState(): void;
    	updateFrontmatter(file: TFile, t: unknown): unknown;
}

// @public
export interface FilePropertiesViewConstructor extends TypedViewConstructor<FilePropertiesView, [
	propertiesPluginInstance: PropertiesPluginInstance
]> {
}

// @public
export interface FilePropertyWidgetComponent extends PropertyWidgetComponentBase {
    	inputEl: HTMLInputElement;
    	type: "file";
}

// @public
export interface FileRecoveryPlugin extends InternalPlugin<FileRecoveryPluginInstance> {
}

// @public
export interface FileRecoveryPluginInstance extends InternalPluginInstance<FileRecoveryPlugin> {
    	app: App;
    	defaultOn: true;
}

// @public
export interface FileSuggest<T> extends EditorSuggest<T> {
    	suggestManager: FileSuggestManager;
}

// @public
export interface FileSuggestManager {
    	app: App;
    	fileSuggestions: null | {
        		file: TFile | null;
        		path: string;
        	}[];
    	getBlockSuggestions(runner: Runnable, file: TFile, text: string): Promise<SearchResult[]>;
    	getDisplaySuggestions(runner: Runnable, linkpath: string, subpath: string, alias: string): Promise<SearchResult[]>;
    	getFileSuggestions(runner: Runnable, text: string): Promise<SearchResult[]>;
    	getGlobalBlockSuggestions(runner: Runnable, text: string): Promise<SearchResult[]>;
    	getGlobalHeadingSuggestions(runner: Runnable, text: string): Promise<SearchResult[]>;
    	getHeadingSuggestions(runner: Runnable, file: TFile, text: string): Promise<SearchResult[]>;
    	getInstructions(): [
    		{
        			command: "string";
        			purpose: "string";
        		}
    	];
    	getSourcePath(): null | string;
    	getSuggestionsAsync(runner: Runnable, text: string): Promise<SearchResult[]>;
    	global: boolean;
    	matchBlock(path: string, file: TFile, block: BlockCache, sourcePath: null | string, content: string, text_parts: string[]): SearchResult | null;
    	mode: "file" | "heading" | "block" | "display" | string;
    	runnable: null | Runnable;
}

// @public
export interface FileSystemWatchHandler {
    	(eventType: "raw" | "folder-created" | "folder-removed" | "file-removed", path: string): void;
    	(eventType: "modified" | "file-created", path: string, oldPath: undefined, stats: FileStats): void;
    	(eventType: "renamed", path: string, oldPath: string): void;
    	(eventType: "closed"): void;
}

// @public
export interface FileTreeItem extends AbstractFileTreeItem<TFile> {
    	isSupported(): boolean;
    	tagEl: HTMLElement | null;
}

// @public
export type FileTreeItemParent = FolderTreeItem | TreeRoot<FileTreeItem | FolderTreeItem>;

// @public
export interface FlatFunction extends BasesFunction {
}

// @public
export interface FloorFunction extends BasesFunction, HasGetDisplayName {
}

// @public
export interface FocusMetadataOptions {
    	focusHeading: boolean;
    	propertyIdx?: number;
    	propertyKey?: string;
}

// @public
export type FocusMode = "both" | "end" | "start";

// @public
export interface Fold {
    	from: number;
    	to: number;
}

// @public
export interface FolderBookmarkItem extends BookmarkItem {
    	path: string;
    	type: "folder";
}

// @public
export interface FolderPropertyWidgetComponent extends PropertyWidgetComponentBase {
    	inputEl: HTMLInputElement;
    	type: "folder";
}

// @public
export interface FolderTreeItem extends AbstractFileTreeItem<TFile>, TreeCollapsibleItem {
    	pusherEl: HTMLElement;
    	sort(): void;
    	vChildren: TreeNodeVChildren<FolderTreeItem | FileTreeItem, FolderTreeItem>;
}

// @public
export interface FoldInfo {
    	folds: Fold[];
    	lines: number;
}

// @public
export interface FoldManager {
    	app: App;
    	cleanup(): unknown;
    	load(arg1: unknown): unknown;
    	loadPath(arg1: unknown): unknown;
    	save(arg1: unknown, arg2: unknown): unknown;
    	savePath(arg1: unknown, arg2: unknown): unknown;
}

// @public
export interface FootnotesPlugin extends InternalPlugin<FootnotesPluginInstance> {
}

// @public
export interface FootnotesPluginInstance extends InternalPluginInstance<FootnotesPlugin> {
    	initLeaf(): void;
}

// @public
export interface FrameDom {
    	eWin: Electron.BrowserWindow;
    	isMac: boolean;
    	leftButtonContainerEl: HTMLDivElement;
    	titleBarEl: HTMLDivElement;
    	titleBarInnerEl: HTMLDivElement;
    	titleBarTextEl: HTMLDivElement;
    	updateStatus(): void;
    	updateTitle(): void;
    	win: Window;
}

// @public
export function getAppConstructor(): AppConstructor;

// @public
export function getInternalPluginConstructor<Instance>(app: App): InternalPluginConstructor<Instance>;

// @public
export function getInternalPluginsConstructor(app: App): InternalPluginsConstructor;

// @public
export interface GetRecentFilesOptions {
    	maxCount?: number;
    	showCanvas?: boolean;
    	showImages?: boolean;
    	showMarkdown?: boolean;
    	showNonAttachments?: boolean;
    	showNonImageAttachments?: boolean;
}

// @public
export function getTFileConstructor(): TFileConstructor;

// @public
export function getTFolderConstructor(): TFolderConstructor;

// @public
export function getViewConstructorByViewType<TViewType extends ViewTypeType>(app: App, viewType: TViewType): ViewTypeViewConstructorMapping[TViewType];

// @public
export interface GlobalSearchPlugin extends InternalPlugin<GlobalSearchPluginInstance> {
}

// @public
export interface GlobalSearchPluginInstance extends InternalPluginInstance<GlobalSearchPlugin> {
    	app: App;
    	defaultOn: true;
    	plugin: GlobalSearchPlugin;
}

// @public
export interface GraphBookmarkItem extends BookmarkItem {
    	options: GraphPluginInstanceOptions;
    	title: string;
    	type: "graph";
}

// @public
export type GraphColor = "arrow" | "circle" | "fill" | "fillAttachment" | "fillFocused" | "fillHighlight" | "fillTag" | "fillUnresolved" | "line" | "lineHighlight" | "text";

// @public
export interface GraphColorAttributes {
    	a: number;
    	rgb: number;
}

// @public
export interface GraphColorGroup {
    	color: GraphColorAttributes;
    	query: string;
}

// @public
export interface GraphColorGroupOptions extends GraphOptions {
    	groups: GraphColorGroupOptionsGroup[];
}

// @public
export interface GraphColorGroupOptionsGroup {
    	color: ColorComponent;
    	el: HTMLDivElement;
    	query: TextComponent;
}

// @public
export interface GraphData {
    	nodes: Record<string, GraphNodeData>;
    	numLinks: number;
}

// @public
export interface GraphDisplayOptions extends GraphOptions {
}

// @public
export interface GraphEngine {
    	app: App;
    	colorGroupOptions: GraphColorGroupOptions;
    	controlsEl: HTMLDivElement;
    	currentFocusFile: string;
    	displayOptions: GraphDisplayOptions;
    	fileFilter: GraphFileFilter;
    	filterOptions: GraphFilterOptions;
    	forceOptions: GraphForceOptions;
    	getOptions(): GraphPluginInstanceOptions;
    	hasFilter: boolean;
    	hoverPopover: unknown;
    	lastHoverLink: unknown;
    	options: GraphPluginInstanceOptions;
    	progression: number;
    	progressionSpeed: number;
    	render(): void;
    	renderer: GraphRenderer;
    	searchQueries: GraphColorGroup[];
    	setOptions(options: GraphPluginInstanceOptions | undefined): void;
    	updateSearch(): void;
    	view: LocalGraphView | GraphView;
}

// @public
export interface GraphFileFilter extends Record<string, GraphColorAttributes | boolean> {
}

// @public
export interface GraphFilterOptions extends GraphOptions {
    	search: SearchComponent;
    	searchSetting: Setting;
}

// @public
export interface GraphForceOptions extends GraphOptions {
}

// @public
export interface GraphForces {
    	centerStrength?: number;
    	linkDistance?: number;
    	linkStrength?: number;
    	repelStrength?: number;
}

// @public
export interface GraphLink {
    	arrow: Graphics | null;
    	clearGraphics(): void;
    	initGraphics(): void;
    	line: Sprite | null;
    	px: Container | null;
    	render(): void;
    	rendered: boolean;
    	renderer: GraphRenderer;
    	source: GraphNode;
    	target: GraphNode;
}

// @public
export interface GraphNode {
    	circle: Graphics | null;
    	clearGraphics(): void;
    	color: GraphColorAttributes;
    	fadeAlpha: number;
    	fontDirty: boolean;
    	forward: Record<string, GraphLink>;
    	fx: number | null;
    	fy: number | null;
    	getDisplayText(): string;
    	getFillColor(): GraphColorAttributes;
    	getRelated(): string[];
    	getSize(): number;
    	getTextStyle(): TextStyle;
    	highlight: Graphics | null;
    	id: string;
    	initGraphics(): void;
    	moveText: number;
    	onClick(e: MouseEvent): void;
    	render(): void;
    	rendered: boolean;
    	renderer: GraphRenderer;
    	reverse: Record<string, GraphLink>;
    	text: Text_2 | null;
    	type: string;
    	weight: number;
    	x: number;
    	y: number;
}

// @public
export interface GraphNodeData {
    	color?: GraphColorAttributes;
    	links: Record<string, boolean>;
    	type: string;
}

// @public
export interface GraphOptions extends TreeCollapsibleItem {
    	getOptions(e: unknown): unknown;
    	setOptions(e: unknown): unknown;
}

// @public
export interface GraphPlugin extends InternalPlugin<GraphPluginInstance> {
}

// @public
export interface GraphPluginInstance extends InternalPluginInstance<GraphPlugin> {
    	app: App;
    	defaultOn: true;
    	onExternalSettingsChange(): Promise<void>;
    	onFileMenu(menu: Menu, file: TAbstractFile, source: string, leaf?: WorkspaceLeaf): void;
    	openGraphView(newLeaf: boolean): void;
    	openLocalGraph(checking: boolean): true | undefined;
    	options: GraphPluginInstanceOptions;
    	plugin: GraphPlugin;
    	saveOptions(): void;
}

// @public
export interface GraphPluginInstanceOptions {
    	"collapse-color-groups"?: boolean;
    	"collapse-display"?: boolean;
    	"collapse-filter"?: boolean;
    	"collapse-forces"?: boolean;
    	centerStrength?: number;
    	close?: boolean;
    	colorGroups?: GraphColorGroup[];
    	hideUnresolved?: boolean;
    	lineSizeMultiplier?: number;
    	linkDistance?: number;
    	linkStrength?: number;
    	localBacklinks?: boolean;
    	localForelinks?: boolean;
    	localInterlinks?: boolean;
    	localJumps?: number;
    	nodeSizeMultiplier?: number;
    	repelStrength?: number;
    	scale?: number;
    	search?: string;
    	showArrow?: boolean;
    	showAttachments?: boolean;
    	showOrphans?: boolean;
    	showTags?: boolean;
    	textFadeMultiplier?: number;
}

// @public
export interface GraphRenderer {
    	changed(): void;
    	colors: Record<GraphColor, GraphColorAttributes>;
    	containerEl: HTMLDivElement;
    	destroy(): void;
    	destroyGraphics(): void;
    	dragNode: GraphNode | null;
    	fLineSizeMult: number;
    	fNodeSizeMult: number;
    	fShowArrow: boolean;
    	fTextShowMult: number;
    	getBackgroundScreenshot(): HTMLCanvasElement;
    	getHighlightNode(): GraphNode | null;
    	getTransparentScreenshot(): ICanvas;
    	hanger: Container;
    	height: number;
    	hidePowerTag: boolean;
    	highlightNode: GraphNode | null;
    	idleFrames: number;
    	iframeEl: HTMLIFrameElement;
    	initGraphics(): void;
    	interactiveEl: HTMLCanvasElement;
    	keyboardActions: KeyboardActions;
    	links: GraphLink[];
    	mouseX: number | null;
    	mouseY: number | null;
    	nodeLookup: Record<string, GraphNode>;
    	nodes: GraphNode[];
    	nodeScale: number;
    	onIframeLoad(): void;
    	onIframeUnload(): void;
    	onMouseMove(evt: MouseEvent): void;
    	onNodeClick(evt: MouseEvent, id: string, type: string): void;
    	onNodeHover(evt: MouseEvent, id: string, type: string): void;
    	onNodeRightClick(evt: MouseEvent, id: string, type: string): void;
    	onNodeUnhover(): void;
    	onPointerDown(renderer: GraphRenderer, evt: PointerEvent): void;
    	onPointerOut(): void;
    	onPointerOver(renderer: GraphRenderer, evt: PointerEvent): void;
    	onResize(): void;
    	onWheel(evt: WheelEvent): void;
    	panning: boolean;
    	panvX: number;
    	panvY: number;
    	panX: number;
    	panY: number;
    	powerTag: PowerTag;
    	px: Application;
    	queueRender(): void;
    	renderCallback(): void;
    	renderTimer: null | number;
    	resetPan(): void;
    	scale: number;
    	setData(data: GraphData): void;
    	setForces(forces: GraphForces): void;
    	setPan(panX: number, panY: number): void;
    	setRenderOptions(options: GraphPluginInstanceOptions): void;
    	setScale(scale: number): void;
    	targetScale: number;
    	testCSS(): void;
    	textAlpha: number;
    	updateZoom(): void;
    	viewport: Coords;
    	width: number;
    	worker: Worker;
    	workerResults: WorkerResults;
    	zoomCenterX: number;
    	zoomCenterY: number;
    	zoomTo(scale: number, pointer: Pointer): void;
}

// @public
export interface GraphView extends ItemView {
    	dataEngine: GraphEngine;
    	getViewType(): typeof ViewType.Graph;
    	onOptionsChange(): void;
    	renderer: GraphRenderer;
    	update(): void;
}

// @public
export interface GraphViewConstructor extends TypedViewConstructor<GraphView> {
}

// @public
export interface GreaterFunction extends BasesFunction, HasGetDisplayName, HasCompare, HasGetRHSWidgetType {
}

// @public
export interface GreaterOrEqualFunction extends BasesFunction, HasGetDisplayName, HasCompare, HasGetRHSWidgetType {
}

// @public
export interface GroupBookmarkItem extends BookmarkItem {
    	items: BookmarkItem[];
    	title: string;
    	type: "group";
}

// @public
export interface HardWrapOptions {
    	allowMerge?: boolean;
    	column?: number;
    	from?: number;
    	to?: number;
}

// @public
export interface HasCompare {
    	compare(a: unknown, b: unknown): boolean;
}

// @public
export interface HasExtract {
    	extract(date: Date): number;
}

// @public
export interface HasGetDisplayName {
    	getDisplayName(type: string): string;
}

// @public
export interface HasGetRHSWidgetType {
    	getRHSWidgetType(type: string): string;
}

// @public
export interface HeaderDom {
    	addNavButton(arg1: unknown, arg2: unknown, arg3: unknown, arg4: unknown): unknown;
    	addSortButton(arg1: unknown, arg2: unknown, arg3: unknown, arg4: unknown): unknown;
    	app: App;
    	navButtonsEl: HTMLDivElement;
    	navHeaderEl: HTMLDivElement;
}

// @public
export interface HeadingInfo {
    	end: EditorPosition;
    	heading: string;
    	start: EditorPosition;
}

// @public
export class HighlightOutline extends Outline {
    	constructor(outlines: unknown, box: unknown, lastPoint: any);
    	get box(): Object | null;
    	get classNamesForOutlining(): string[];
    	lastPoint: unknown;
    	serialize(bbox: [
    		blX: string,
    		blY: string,
    		trX: string,
    		trY: string
    	], rotation: number): Array<Array<number>>;
}

// @public
export class HighlightOutliner {
    	constructor(boxes: Array<Object>, borderWidth?: number, innerMargin?: number, isLTR?: boolean);
    	getOutlines(): HighlightOutline;
}

// @public
export interface HotkeyManager {
    	addDefaultHotkeys(command: string, keys: KeymapInfo[]): void;
    	app: App;
    	bake(): void;
    	baked: boolean;
    	bakedHotkeys: KeymapInfo[];
    	bakedIds: string[];
    	customKeys: HotkeyManagerCustomKeysRecord;
    	defaultKeys: HotkeyManagerDefaultKeysRecord;
    	getDefaultHotkeys(command: string): KeymapInfo[];
    	getHotkeys(command: string): KeymapInfo[];
    	load(): void;
    	onConfigFileChange: Debouncer<[
    	], Promise<void>>;
    	onRaw(e: unknown): void;
    	onTrigger(event: KeyboardEvent, keypress: KeymapInfo): boolean;
    	printHotkeyForCommand(commandId: string): string;
    	registerListeners(): void;
    	removeDefaultHotkeys(command: string): void;
    	removeHotkeys(command: string): void;
    	save(): void;
    	setHotkeys(command: string, keys: KeymapInfo[]): void;
}

// @public
export interface HotkeyManagerCustomKeysRecord extends Record<string, KeymapInfo[]> {
}

// @public
export interface HotkeyManagerDefaultKeysRecord extends Record<string, KeymapInfo[]> {
}

// @public
export interface HotkeysSettingTab extends SettingTab {
    	searchComponent: SearchComponent;
    	updateHotkeyVisibility(): void;
}

// @public
export interface HourFunction extends BasesFunction, HasExtract {
}

// @public
export interface HoverLinkEvent {
    	event: MouseEvent;
    	hoverParent: WorkspaceLeaf;
    	linktext: string;
    	source: "search" | "editor" | "preview" | "properties" | "graph" | "file-explorer" | "hover-link";
    	sourcePath?: string;
    	state?: HoverLinkEventState;
    	targetEl: HTMLElement | null;
}

// @public
export interface HoverLinkEventState {
    	scroll: unknown;
}

// @public
export interface IfFunction extends BasesFunction {
}

// @public
export interface IFramedMarkdownEditor extends MarkdownScrollableEditView {
    	cleanup: null | (() => void);
    	cleanupIframe(): void;
    	getDynamicExtensions(): Extension[];
    	iframeEl: null | HTMLIFrameElement;
    	onIframeLoad(): void;
    	onunload(): void;
    	onUpdate(update: ViewUpdate, changed: boolean): void;
}

// @public
export interface ImageView extends EditableFileView {
    	getViewType(): typeof ViewType.Image;
}

// @public
export interface ImageViewConstructor extends TypedViewConstructor<ImageView> {
}

// @public
export interface ImportedAttachment {
    	data: Promise<ArrayBuffer>;
    	extension: string;
    	filepath: string;
    	name: string;
}

// @public
export interface IndexFunction extends BasesFunction, HasGetDisplayName, HasGetRHSWidgetType {
}

// @public
export interface InfinityScroll {
    	compute(x: unknown): unknown;
    	findElementTop(x: unknown, y: unknown, z: unknown): unknown;
    	getRootTop(): unknown;
    	height: number;
    	invalidate(x: unknown, y: unknown): unknown;
    	invalidateAll(): unknown;
    	lastScroll: number;
    	_layout(x: unknown, y: unknown): unknown;
    	measure(x: unknown, y: unknown): unknown;
    	_measure(x: unknown): unknown;
    	onResize(): unknown;
    	onScroll(): unknown;
    	_precompute(x: unknown): unknown;
    	queueCompute(): unknown;
    	queued: unknown | null;
    	renderBlockSize: number;
    	rootEl: unknown;
    	scrollEl: HTMLElement;
    	scrollIntoView(x: unknown, y: unknown): unknown;
    	setWidth: boolean;
    	update(x: unknown, y: unknown, z: unknown, u: unknown, v: unknown, w: unknown): unknown;
    	updateVirtualDisplay(x: unknown): unknown;
    	width: number;
}

// @public
export interface InfoFileView extends FileView {
    	onFileOpen(file: TFile): void;
}

// @public
export interface InFolderFunction extends BasesFunction, HasGetDisplayName, HasGetRHSWidgetType {
}

// @public
export interface InstallThemeOptions {
    	author: string;
    	name: string;
    	repo: string;
}

// @public
export interface InternalPlugin<InternalPluginInstance> extends Component {
    	addedButtonEls: HTMLDivElement[];
    	addSettingTab(settingTab: PluginSettingTab): void;
    	app: App;
    	commands: Command[];
    	deleteData(): Promise<void>;
    	disable(isDisabledByUser?: boolean): void;
    	enable(isEnabledByUser?: boolean): Promise<void>;
    	enabled: boolean;
    	getModifiedTime(): Promise<number | undefined>;
    	handleConfigFileChange(): Promise<void>;
    	hasStatusBarItem: boolean;
    	init(): void;
    	instance: InternalPluginInstance;
    	lastSave: number;
    	loadData(): Promise<object | null>;
    	manager: InternalPlugins;
    	mobileFileInfo: MobileFileInfo[];
    	onConfigFileChange: Debouncer<[
    	], Promise<void>>;
    	registerGlobalCommand(command: Command): void;
    	registerMobileFileInfo(renderCallback: (el: HTMLElement) => void): void;
    	registerRibbonItem(title: string, icon: IconName, callback: () => Promise<void>): void;
    	registerStatusBarItem(): void;
    	registerViewType(type: string, creator: ViewCreator): void;
    	ribbonItems: RibbonItem[];
    	saveData(data: object): Promise<void>;
    	statusBarEl: HTMLDivElement | null;
    	views: Record<string, ViewCreator>;
}

// @public
export interface InternalPluginConstructor<Instance> extends ConstructorBase<[
	app: App,
	instance: Instance,
	internalPlugins: InternalPlugins
], InternalPlugin<Instance>> {
}

// @public
export interface InternalPluginInstance<InternalPlugin> {
    	description: string;
    	id: string;
    	init(app: App, plugin: InternalPlugin): void;
    	name: string;
    	onDisable?(app: App, plugin: InternalPlugin): void;
    	onEnable?(app: App, plugin: InternalPlugin): Promise<void>;
    	onUserDisable?(app: App): void;
    	onUserEnable?(app: App): void;
}

// @public
export const InternalPluginName: {
    	readonly AudioRecorder: "audio-recorder";
    	readonly Backlink: "backlink";
    	readonly Bases: "bases";
    	readonly Bookmarks: "bookmarks";
    	readonly Canvas: "canvas";
    	readonly CommandPalette: "command-palette";
    	readonly DailyNotes: "daily-notes";
    	readonly EditorStatus: "editor-status";
    	readonly FileExplorer: "file-explorer";
    	readonly FileRecovery: "file-recovery";
    	readonly Footnotes: "footnotes";
    	readonly GlobalSearch: "global-search";
    	readonly Graph: "graph";
    	readonly MarkdownImporter: "markdown-importer";
    	readonly NoteComposer: "note-composer";
    	readonly OutgoingLink: "outgoing-link";
    	readonly Outline: "outline";
    	readonly PagePreview: "page-preview";
    	readonly Properties: "properties";
    	readonly Publish: "publish";
    	readonly RandomNote: "random-note";
    	readonly SlashCommand: "slash-command";
    	readonly Slides: "slides";
    	readonly Switcher: "switcher";
    	readonly Sync: "sync";
    	readonly TagPane: "tag-pane";
    	readonly Templates: "templates";
    	readonly Webviewer: "webviewer";
    	readonly WordCount: "word-count";
    	readonly Workspaces: "workspaces";
    	readonly ZkPrefixer: "zk-prefixer";
};

// @public
export type InternalPluginNameInstancesMapping = {
    	[InternalPluginName.AudioRecorder]: AudioRecorderPluginInstance;
    	[InternalPluginName.Backlink]: BacklinkPluginInstance;
    	[InternalPluginName.Bases]: BasesPluginInstance;
    	[InternalPluginName.Bookmarks]: BookmarksPluginInstance;
    	[InternalPluginName.Webviewer]: WebviewerPluginInstance;
    	[InternalPluginName.Canvas]: CanvasPluginInstance;
    	[InternalPluginName.CommandPalette]: CommandPalettePluginInstance;
    	[InternalPluginName.DailyNotes]: DailyNotesPluginInstance;
    	[InternalPluginName.EditorStatus]: EditorStatusPluginInstance;
    	[InternalPluginName.FileExplorer]: FileExplorerPluginInstance;
    	[InternalPluginName.FileRecovery]: FileRecoveryPluginInstance;
    	[InternalPluginName.Footnotes]: FootnotesPluginInstance;
    	[InternalPluginName.GlobalSearch]: GlobalSearchPluginInstance;
    	[InternalPluginName.Graph]: GraphPluginInstance;
    	[InternalPluginName.MarkdownImporter]: MarkdownImporterPluginInstance;
    	[InternalPluginName.NoteComposer]: NoteComposerPluginInstance;
    	[InternalPluginName.OutgoingLink]: OutgoingLinkPluginInstance;
    	[InternalPluginName.Outline]: OutlinePluginInstance;
    	[InternalPluginName.PagePreview]: PagePreviewPluginInstance;
    	[InternalPluginName.Properties]: PropertiesPluginInstance;
    	[InternalPluginName.Publish]: PublishPluginInstance;
    	[InternalPluginName.RandomNote]: RandomNotePluginInstance;
    	[InternalPluginName.SlashCommand]: SlashCommandPluginInstance;
    	[InternalPluginName.Slides]: SlidesPluginInstance;
    	[InternalPluginName.Switcher]: SwitcherPluginInstance;
    	[InternalPluginName.Sync]: SyncPluginInstance;
    	[InternalPluginName.TagPane]: TagPanePluginInstance;
    	[InternalPluginName.Templates]: TemplatesPluginInstance;
    	[InternalPluginName.WordCount]: WordCountPluginInstance;
    	[InternalPluginName.Workspaces]: WorkspacesPluginInstance;
    	[InternalPluginName.ZkPrefixer]: ZkPrefixerPluginInstance;
};

// @public
export type InternalPluginNamePluginsMapping = {
    	[InternalPluginName.AudioRecorder]: AudioRecorderPlugin;
    	[InternalPluginName.Backlink]: BacklinkPlugin;
    	[InternalPluginName.Bases]: BasesPlugin;
    	[InternalPluginName.Bookmarks]: BookmarksPlugin;
    	[InternalPluginName.Webviewer]: WebviewerPlugin;
    	[InternalPluginName.Canvas]: CanvasPlugin;
    	[InternalPluginName.CommandPalette]: CommandPalettePlugin;
    	[InternalPluginName.DailyNotes]: DailyNotesPlugin;
    	[InternalPluginName.EditorStatus]: EditorStatusPlugin;
    	[InternalPluginName.FileExplorer]: FileExplorerPlugin;
    	[InternalPluginName.FileRecovery]: FileRecoveryPlugin;
    	[InternalPluginName.Footnotes]: FootnotesPlugin;
    	[InternalPluginName.GlobalSearch]: GlobalSearchPlugin;
    	[InternalPluginName.Graph]: GraphPlugin;
    	[InternalPluginName.MarkdownImporter]: MarkdownImporterPlugin;
    	[InternalPluginName.NoteComposer]: NoteComposerPlugin;
    	[InternalPluginName.OutgoingLink]: OutgoingLinkPlugin;
    	[InternalPluginName.Outline]: OutlinePlugin;
    	[InternalPluginName.PagePreview]: PagePreviewPlugin;
    	[InternalPluginName.Properties]: PropertiesPlugin;
    	[InternalPluginName.Publish]: PublishPlugin;
    	[InternalPluginName.RandomNote]: RandomNotePlugin;
    	[InternalPluginName.SlashCommand]: SlashCommandPlugin;
    	[InternalPluginName.Slides]: SlidesPlugin;
    	[InternalPluginName.Switcher]: SwitcherPlugin;
    	[InternalPluginName.Sync]: SyncPlugin;
    	[InternalPluginName.TagPane]: TagPanePlugin;
    	[InternalPluginName.Templates]: TemplatesPlugin;
    	[InternalPluginName.WordCount]: WordCountPlugin;
    	[InternalPluginName.Workspaces]: WorkspacesPlugin;
    	[InternalPluginName.ZkPrefixer]: ZkPrefixerPlugin;
};

// @public
export type InternalPluginNameType = (typeof InternalPluginName)[keyof typeof InternalPluginName];

// @public
export interface InternalPlugins extends Events {
    	app: App;
    	config: InternalPluginsConfigRecord;
    	enable(): Promise<void>;
    	getEnabledPluginById<ID extends InternalPluginNameType>(id: ID): InternalPluginNameInstancesMapping[ID] | null;
    	getEnabledPlugins(): InternalPlugin<unknown>[];
    	getPluginById<ID extends InternalPluginNameType>(id: ID): InternalPluginNamePluginsMapping[ID] | null;
    	loadPlugin<Instance extends InternalPluginInstance<unknown>>(internalPluginInstance: Instance): Instance;
    	onRaw(configPath: string): void;
    	plugins: InternalPluginNamePluginsMapping;
    	requestSaveConfig: Debouncer<[
    	], Promise<void>>;
    	saveConfig(): Promise<void>;
}

// @public
export interface InternalPluginsConfigRecord extends Record<InternalPluginNameType, boolean> {
}

// @public
export interface InternalPluginsConstructor extends ConstructorBase<[
	app: App
], InternalPlugins> {
}

// @public
export function isEmbedCache(reference: Reference): reference is EmbedCache;

// @public
export function isFrontmatterLinkCache(reference: Reference): reference is FrontmatterLinkCache;

// @public
export function isLinkCache(reference: Reference): reference is LinkCache;

// @public
export function isReferenceCache(reference: Reference): reference is ReferenceCache;

// @public
export interface ItemQueue<T> {
    	add(item: T): void;
    	addList(items: T[]): void;
    	cancel(): void;
    	clear(): void;
    	generator(): AsyncGenerator<T>;
    	items: ItemQueueItems<T>;
    	notify(): void;
    	promise: PromiseWithResolvers<T> | null;
    	remove(item: T): void;
    	runnable: Runnable;
}

// @public
export interface ItemQueueItems<T> {
    	clear(): void;
    	dequeue(): T | undefined;
    	enqueue(item: T): void;
    	enqueueArray(items: T[]): void;
    	get(): T[];
    	isEmpty(): boolean;
    	length: number;
    	offset: number;
    	peek(): T | undefined;
    	queue: T[];
    	remove(item: T): void;
}

// @public
export interface JoinFunction extends BasesFunction {
}

// @public
export interface KeyboardActions {
    	down?: boolean;
    	left?: boolean;
    	right?: boolean;
    	shift?: boolean;
    	up?: boolean;
    	zoomin?: boolean;
    	zoomout?: boolean;
}

// @public
export interface KeyScope {
    	func(): void;
    	key: string | null;
    	modifiers: string | null;
    	scope: Scope;
}

// @public (undocumented)
export interface LanguageState {
    	apply(tr: Transaction): LanguageState;
    	context: ParseContext;
    	tree: Tree_2;
}

// @public
export interface LeafEntry {
    	children?: LeafEntry[];
    	direction?: SplitDirection;
    	id: string;
    	state?: ViewState;
    	type: string;
    	width?: number;
}

// @public
export interface LenFunction extends BasesFunction {
}

// @public
export interface LessFunction extends BasesFunction, HasGetDisplayName, HasCompare, HasGetRHSWidgetType {
}

// @public
export interface LessOrEqualFunction extends BasesFunction, HasGetDisplayName, HasCompare, HasGetRHSWidgetType {
}

// @public
export interface LineHandle {
    	index: number;
    	row: number;
}

// @public
export interface LineHandleChange {
    	changes: ChangeDesc;
}

// @public
export interface LinkChangeUpdate {
    	change: string;
    	reference: ReferenceCache;
    	sourcePath: string;
}

// @public
export interface LinksToFunction extends BasesFunction, HasGetDisplayName, HasGetRHSWidgetType {
}

// @public
export interface LinkSuggestion {
    	alias?: string;
    	file: TFile | null;
    	path: string;
}

// @public
export interface LinkUpdate {
    	reference: PositionedReference;
    	resolvedFile: TFile;
    	resolvedPaths: string[];
    	sourceFile: TFile;
}

// @public
export interface LinkUpdater {
    	applyUpdates(file: TFile, updates: LinkChangeUpdate[]): Promise<void>;
    	iterateReferences(callback: (path: string, reference: ReferenceCache) => void): void;
    	renameSubpath(file: TFile, oldSubpath: string, newSubpath: string): Promise<void>;
}

// @public
export interface LinkUpdaters extends Record<string, LinkUpdater> {
    	canvas?: CanvasLinkUpdater;
}

// @public
export type LinkUpdatesHandler = (linkUpdates: LinkUpdate[]) => Promise<void>;

// @public
export interface LoadProgress {
}

// @public
export interface LocalGraphView extends InfoFileView {
    	engine: GraphEngine;
    	getViewType(): typeof ViewType.LocalGraph;
    	onFileChanged(file: TFile): void;
    	onOptionsChange(): void;
    	renderer: GraphRenderer;
    	update(): void;
}

// @public
export interface LocalGraphViewConstructor extends TypedViewConstructor<LocalGraphView> {
}

// @public
export interface Localization {
    	[key: string]: string | Localization;
}

// @public
export interface MapOfSets<Key, Value> {
    	add(key: Key, value: Value): void;
    	data: Map<Key, Set<Value>>;
    	delete(key: Key, value: Value): void;
    	get(key: Key): Set<Value> | null;
    	getArray(key: Key): Value[];
}

// @public
export type Mapping = {
    	[TViewType in ViewTypeType]: TypedViewCreator<ViewTypeViewMapping[TViewType]>;
};

// @public
export interface MarkdownBaseView extends Component {
    	get activeCM(): EditorView;
    	app: App;
    	applyFoldInfo(info: FoldInfo): void;
    	buildLocalExtensions(): Extension[];
    	cleanupLivePreview: null | (() => void);
    	clear(): void;
    	clipboardManager: ClipboardManager;
    	cm: EditorView;
    	cmInit: boolean;
    	containerEl: HTMLElement;
    	cursorPopupEl: HTMLElement | null;
    	destroy(): void;
    	destroyTableCell(cell?: TableCellEditor): void;
    	editor?: Editor;
    	editorEl: HTMLElement;
    	editorSuggest: EditorSuggests;
    	editTableCell(cell: TableEditor, new_cell: TableCell): TableCellEditor;
    	get file(): TFile | null;
    	get(): string;
    	getDynamicExtensions(): Extension[];
    	getFoldInfo(): null | FoldInfo;
    	getLocalExtensions(): unknown;
    	livePreviewPlugin: Extension[];
    	localExtensions: Extension[];
    	onContextMenu(event: PointerEvent, x: boolean): Promise<void>;
    	onEditorClick(event: MouseEvent, element?: HTMLElement): void;
    	onEditorDragStart(event: DragEvent): void;
    	onEditorLinkMouseover(event: MouseEvent, target: HTMLElement): void;
    	// @deprecated
    onMenu(event: MouseEvent): void;
    	onResize(): void;
    	onUpdate(update: ViewUpdate, changed: boolean): void;
    	owner: MarkdownFileInfo;
    	get path(): string;
    	reinit(): void;
    	reparent(new_container: HTMLElement): void;
    	resetSyntaxHighlighting(): void;
    	saveHistory(): void;
    	set(data: string, clear: boolean): void;
    	sourceMode: boolean;
    	tableCell: null | TableCellEditor;
    	toggleFoldFrontmatter(): void;
    	toggleSource(): void;
    	triggerClickableToken(token: Token, new_leaf: boolean): void;
    	updateEvent(): (update: ViewUpdate) => void;
    	updateLinkPopup(): void;
    	updateOptions(): void;
}

// @public
export interface MarkdownEditViewEphemeralState {
    	cursor: EditorRange;
}

// @public
export interface MarkdownImporterPlugin extends InternalPlugin<MarkdownImporterPluginInstance> {
}

// @public
export interface MarkdownImporterPluginInstance extends InternalPluginInstance<MarkdownImporterPlugin> {
    	app: App;
}

// @public
export interface MarkdownScrollableEditView extends MarkdownBaseView {
    	applyScroll(scroll: number): void;
    	buildLocalExtensions(): Extension[];
    	cssClasses: [
    	];
    	focus(): void;
    	getDynamicExtensions(): Extension[];
    	getScroll(): number;
    	handleScroll(): void;
    	hide(): void;
    	isScrolling: boolean;
    	onCssChange(): void;
    	onResize(): void;
    	onScroll(): void;
    	onUpdate(update: ViewUpdate, changed: boolean): void;
    	onViewClick(event?: MouseEvent): void;
    	scope: Scope | undefined;
    	search: EditorSearchComponent;
    	setCssClass(classes: string[]): void;
    	show(): void;
    	showSearch(replace: boolean): void;
    	sizerEl: HTMLElement;
    	updateBottomPadding(height: number): void;
}

// @public
export interface MarkdownViewConstructor extends TypedViewConstructor<MarkdownView> {
}

// @public
export interface MarkdownViewEphemeralState extends Record<string, unknown> {
    	scroll: number;
}

// @public
export interface MarkdownViewModes {
    	preview: MarkdownPreviewView;
    	source: MarkdownEditView;
}

// @public
export interface MarkdownViewSourceMode {
    	cmEditor: unknown;
}

// @public
export interface MatchingBracket {
    	to?: EditorPosition;
}

// @public
export interface MathJax {
    	chtmlStylesheet(): HTMLStyleElement;
    	config: unknown;
    	getMetricsFor(node: HTMLElement, display?: boolean): ExtendedMetrics;
    	loader: unknown;
    	options: unknown;
    	tex2chtml(math: string, options?: Record<string, unknown>): HTMLElement;
    	tex2chtmlPromise(math: string, options?: Record<string, unknown>): Promise<HTMLElement>;
    	tex2mml(math: string, options?: Record<string, unknown>): string;
    	tex2mmlPromise(math: string, options?: Record<string, unknown>): Promise<string>;
    	texReset(): void;
    	typeset(elements?: unknown[] | null): void;
    	typesetClear(elements?: unknown[] | null): void;
    	typesetPromise(elements?: unknown[] | null): Promise<void>;
    	version: string;
}

// @public
export type MaybeDeferredView<TView extends View> = TView | DeferredView;

// @public
export interface MenuSubmenuConfigRecord extends Record<string, {
    	title: string;
    	icon: string;
}> {
}

// @public
export interface MetadataCacheFileCacheRecord extends Record<string, FileCacheEntry> {
}

// @public
export interface MetadataCacheMetadataCacheRecord extends Record<string, CachedMetadata> {
}

// @public
export interface MetadataCacheWorkerMessage {
    	data: CachedMetadata;
}

// @public
export interface MetadataEditor extends Component {
    	addProperty(): void;
    	addPropertyButtonEl: HTMLButtonElement;
    	app: App;
    	clear(): void;
    	clearSelection(): void;
    	collapsed: boolean;
    	containerEl: HTMLElement;
    	contentEl: HTMLElement;
    	_copyToClipboard(event: ClipboardEvent, properties: MetadataEditorProperty[]): void;
    	focusedLine: null | MetadataEditorProperty;
    	focusKey(key: string): void;
    	focusProperty(property: MetadataEditorProperty): void;
    	focusPropertyAtIndex(index: number): void;
    	focusValue(value: string, mode: FocusMode): void;
    	foldEl: HTMLElement;
    	handleCopy(event: ClipboardEvent): void;
    	handleCut(event: ClipboardEvent): void;
    	handleItemSelection(event: PointerEvent, property: MetadataEditorProperty): boolean;
    	handleKeypress(event: KeyboardEvent): void;
    	handlePaste(event: ClipboardEvent): void;
    	hasFocus(): boolean;
    	hasPropertyFocused(): boolean;
    	headingEl: HTMLElement;
    	hoverPopover: null | HoverPopover;
    	insertProperties(properties: Record<string, any>): void;
    	onload(): void;
    	onMetadataTypeChange(property: MetadataEditorProperty): void;
    	owner: MarkdownView;
    	properties: PropertyEntryData<unknown>[];
    	propertyListEl: HTMLElement;
    	removeProperties(properties: MetadataEditorProperty[], reset_focus?: boolean): unknown;
    	rendered: MetadataEditorProperty[];
    	reorderKey(entry: PropertyEntryData<unknown>, index: number): unknown;
    	save(): void;
    	selectAll(): void;
    	selectedLines: Set<MetadataEditorProperty>;
    	selectProperty(property: MetadataEditorProperty | undefined, select: boolean): void;
    	serialize(): Record<string, any>;
    	setCollapse(collapsed: boolean, x: boolean): void;
    	showPropertiesMenu(event: MouseEvent): void;
    	synchronize(data: Record<string, any>): void;
    	toggleCollapse(): void;
}

// @public
export interface MetadataEditorProperty extends Component {
    	app: App;
    	containerEl: HTMLElement;
    	entry: PropertyEntryData<unknown>;
    	focusKey(): void;
    	focusProperty(): void;
    	focusValue(mode?: FocusMode): void;
    	handleItemClick(event: MouseEvent): void;
    	handlePropertyBlur(): void;
    	handleUpdateKey(key: string): boolean;
    	handleUpdateValue(value: unknown): void;
    	iconEl: HTMLSpanElement;
    	keyEl: HTMLElement;
    	keyInputEl: HTMLInputElement;
    	metadataEditor: MetadataEditor;
    	onload(): void;
    	rendered: MetadataWidget | null;
    	renderProperty(entry: PropertyEntryData<unknown>, check_errors?: boolean, use_expected_type?: boolean): void;
    	setSelected(selected: boolean): void;
    	showPropertyMenu(event: MouseEvent): void;
    	typeInfo: MetadataEditorPropertyTypeInfo;
    	valueEl: HTMLElement;
    	warningEl: HTMLElement;
}

// @public
export interface MetadataEditorPropertyTypeInfo {
    	expected: PropertyWidget;
    	inferred: PropertyWidget;
}

// @public
export interface MetadataTypeManager extends Events {
    	app: App;
    	assignedWidgets: MetadataTypeManagerTypesRecord;
    	getAllProperties(): Record<string, PropertyInfo>;
    	getAssignedWidget(property: string): PropertyWidgetType | null;
    	getPropertyInfo(property: string): PropertyInfo;
    	getTypeInfo(property: string, value: unknown): TypeInfo;
    	getWidget(type: string): PropertyWidget;
    	lastSave: number;
    	loadData(): Promise<void>;
    	onConfigFileChange: Debouncer<[
    	], Promise<void>>;
    	onRaw(e: unknown): void;
    	properties: MetadataTypeManagerPropertiesRecord;
    	registeredTypeWidgets: MetadataTypeManagerRegisteredTypeWidgetsRecord;
    	registerListeners(): void;
    	save(): Promise<void>;
    	setType(property: string, type: PropertyWidgetType): Promise<void>;
    	unsetType(property: string): Promise<void>;
    	updatePropertyInfoCache(): void;
}

// @public
export interface MetadataTypeManagerPropertiesRecord extends Record<string, PropertyInfo> {
}

// @public
export interface MetadataTypeManagerRegisteredTypeWidgetsRecord extends Record<PropertyWidgetType, PropertyWidget> {
    	aliases: PropertyWidget<AliasesPropertyWidgetComponent>;
    	checkbox: PropertyWidget<CheckboxPropertyWidgetComponent>;
    	date: PropertyWidget<DatePropertyWidgetComponent>;
    	datetime: PropertyWidget<DatetimePropertyWidgetComponent>;
    	file: PropertyWidget<FilePropertyWidgetComponent>;
    	folder: PropertyWidget<FolderPropertyWidgetComponent>;
    	multitext: PropertyWidget<MultitextPropertyWidgetComponent>;
    	number: PropertyWidget<NumberPropertyWidgetComponent>;
    	property: PropertyWidget<PropertyPropertyWidgetComponent>;
    	tags: PropertyWidget<TagsPropertyWidgetComponent>;
    	text: PropertyWidget<TextPropertyWidgetComponent>;
}

// @public
export interface MetadataTypeManagerTypesRecord extends Record<string, PropertyWidgetEntry> {
}

// @public
export interface MetadataWidget {
}

// @public
export interface MinFunction extends BasesFunction {
}

// @public
export interface MinuteFunction extends BasesFunction, HasExtract {
}

// @public
export interface MobileFileInfo {
    	renderCallback(el: HTMLElement): void;
}

// @public
export interface MobileNavbar {
}

// @public
export interface MobileTabSwitcher {
    	app: App;
    	cacheDir: string;
    	close(): void;
    	containerEl: HTMLDivElement;
    	hide(): void;
    	innerScrollEl: HTMLDivElement;
    	isVisible: boolean;
    	onLayoutChange(): void;
    	render(): void;
    	requestRender: Debouncer<[
    	], void>;
    	scrollEl: HTMLDivElement;
    	setupCacheDir(): Promise<void>;
    	show(): Promise<void>;
    	showTabManagementMenu(e: MouseEvent): void;
    	tabPreviewLookup: WeakMap<object, unknown>;
}

// @public
export interface MobileToolbar {
}

// @public
export interface MonthFunction extends BasesFunction, HasExtract {
}

// @public
export interface Multiselect {
    	addElement(value: string): boolean;
    	allowCreatingOptions(createOption: (this: Multiselect, value: string) => string | undefined): this;
    	changeCallback?(values: string[]): void;
    	_createElement(value: string): string | null;
    	_createInputEl(): HTMLDivElement;
    	createOption?(this: Multiselect, value: string): string | undefined;
    	editElement(index: number): void;
    	elements: HTMLDivElement[];
    	findDuplicate?(value: string, values: string[]): number;
    	focusElement(index: number): void;
    	inputEl: HTMLDivElement;
    	readonly inputText: string;
    	onChange(changeCallback: (values: string[]) => void): void;
    	onOptionContextmenu?(this: Multiselect, menu: Menu, value: string, ctx: MultiselectOptionContextMenuContext): void;
    	optionRenderer?(value: string, ctx: MultiselectOptionContextMenuContext): void;
    	preventDuplicates(findDuplicate: (value: string, values: string[]) => number): this;
    	removeElement(index: number, shouldFocus?: boolean): void;
    	renderValues(): void;
    	rootEl: HTMLDivElement;
    	setInputText(text: string): void;
    	setOptionContextmenuHandler(onOptionContextmenu: (this: Multiselect, menu: Menu, value: string, ctx: MultiselectOptionContextMenuContext) => void): this;
    	setOptionRenderer(optionRenderer: (value: string, ctx: MultiselectOptionContextMenuContext) => void): this;
    	setupInput?(this: Multiselect, inputEl: HTMLDivElement, initializer: (value: string, shouldFocus?: boolean) => unknown): void;
    	setupInputEl(setupInput: (this: Multiselect, inputEl: HTMLDivElement, initializer: (value: string, shouldFocus?: boolean) => unknown) => void): this;
    	setValues(values: string[] | null): this;
    	triggerChange(): void;
    	values: string[];
}

// @public
export interface MultiselectOptionContextMenuContext {
    	el: HTMLDivElement;
    	pillEl: HTMLDivElement;
}

// @public
export interface MultitextPropertyWidgetComponent extends PropertyWidgetComponentBase {
    	hoverPopover: HoverPopover | null;
    	multiselect: Multiselect;
    	type: "multitext";
    	valueSet: Set<string>;
}

// @public
export interface NodeInteractionLayer {
    	canvas: CanvasViewCanvas;
    	interactionEl: HTMLDivElement;
    	render(): unknown;
    	setTarget(arg1: unknown): unknown;
    	target: null;
}

// @public
export interface NotContainsFunction extends BasesFunction {
}

// @public
export interface NoteComposerPlugin extends InternalPlugin<NoteComposerPluginInstance> {
}

// @public
export interface NoteComposerPluginInstance extends InternalPluginInstance<NoteComposerPlugin> {
    	app: App;
    	applyTemplate(content: string, fromTitle: string, newTitle: string): Promise<string>;
    	defaultOn: true;
    	extractHeading(file: TFile, editor: Editor): void;
    	getSelectionUnderHeading(file: TFile, editor: Editor, line: number): HeadingInfo | null;
    	onEditorMenu(menu: Menu, editor: Editor, info: MarkdownView | MarkdownFileInfo): void;
    	onEnable: (app: App, plugin: NoteComposerPlugin) => Promise<void>;
    	onExternalSettingsChange(): Promise<void>;
    	onFileMenu(menu: Menu, file: TFile, source: string): void;
    	options: NoteComposerPluginOptions;
    	pluginInstance: NoteComposerPlugin;
}

// @public
export interface NoteComposerPluginOptions {
    	askBeforeMerging?: boolean;
    	replacementText?: "link" | "embed" | "none";
    	template?: string;
}

// @public
export interface NotEmptyFunction extends BasesFunction, HasGetDisplayName, HasGetRHSWidgetType {
}

// @public
export interface NotEqualFunction extends BasesFunction, HasGetDisplayName, HasCompare, HasGetRHSWidgetType {
}

// @public
export interface NotFunction extends BasesFunction {
}

// @public
export interface NowFunction extends BasesFunction {
}

// @public
export interface NumberPropertyWidgetComponent extends PropertyWidgetComponentBase {
    	inputEl: HTMLInputElement;
    	showError(): void;
    	type: "number";
}

// @public
export interface ObsidianDOM {
    	appContainerEl: HTMLElement;
    	horizontalMainContainerEl: HTMLElement;
    	statusBarEl: HTMLElement;
    	workspaceEl: HTMLElement;
}

// @public
export interface ObsidianTouchEvent {
    	direction: "x" | "y";
    	evt: TouchEvent;
    	points: number;
    	registerCallback: ObsidianTouchEventRegisterCallback;
    	startX: number;
    	startY: number;
    	targetEl: HTMLElement;
    	touch: Touch;
    	x: number;
    	y: number;
}

// @public
export interface ObsidianTouchEventRegisterCallback {
    	cancel(): void;
    	finish(x: number, y: number, z: number): void;
    	move(x: number): void;
}

// @public
export interface OpenDialogOptions {
    	bottom: number;
    	closeOnBlur: boolean;
    	closeOnEnter: boolean;
    	onClose(div: HTMLDivElement): void;
    	onInput(e: KeyboardEvent, value: string, callback: (value: unknown) => void): void;
    	onKeyDown(e: KeyboardEvent, value: string, callback: (value: unknown) => void): void;
    	onKeyUp(e: KeyboardEvent, value: string, callback: (value: unknown) => void): void;
    	selectValueOnOpen: boolean;
    	value: string;
}

// @public
export interface OpenNotificationOptions {
    	bottom?: boolean;
    	duration?: number;
}

// @public
export interface OutgoingLinkPlugin extends InternalPlugin<OutgoingLinkPluginInstance> {
}

// @public
export interface OutgoingLinkPluginInstance extends InternalPluginInstance<OutgoingLinkPlugin> {
    	app: App;
    	defaultOn: true;
    	plugin: OutgoingLinkPlugin;
}

// @public
export interface OutgoingLinkView extends InfoFileView {
    	getViewType(): typeof ViewType.OutgoingLink;
    	update(): void;
}

// @public
export interface OutgoingLinkViewConstructor extends TypedViewConstructor<OutgoingLinkView> {
}

// @public
export class Outline {
    	get box(): Object | null;
    	static createBezierPoints(x1: unknown, y1: unknown, x2: unknown, y2: unknown, x3: unknown, y3: unknown): number[];
    	static _normalizePagePoint(x: unknown, y: unknown, rotation: unknown): unknown[];
    	static _normalizePoint(x: unknown, y: unknown, parentWidth: unknown, parentHeight: unknown, rotation: unknown): number[];
    	static PRECISION: number;
    	static _rescale(src: unknown, tx: unknown, ty: unknown, sx: unknown, sy: unknown, dest: unknown): unknown;
    	static _rescaleAndSwap(src: unknown, tx: unknown, ty: unknown, sx: unknown, sy: unknown, dest: unknown): unknown;
    	serialize(bbox: [
    		blX: string,
    		blY: string,
    		trX: string,
    		trY: string
    	], rotation: number): void;
    	static svgRound(x: unknown): number;
    	toSVGPath(): string;
    	static _translate(src: unknown, tx: unknown, ty: unknown, dest: unknown): unknown;
}

// @public
export interface OutlinePlugin extends InternalPlugin<OutlinePluginInstance> {
}

// @public
export interface OutlinePluginInstance extends InternalPluginInstance<OutlinePlugin> {
    	app: App;
    	defaultOn: true;
    	plugin: OutlinePlugin;
}

// @public
export interface OutlineView extends InfoFileView {
    	createItemDom(e: unknown): unknown;
    	filterSearchResults(): void;
    	findActiveHeading(e: unknown): unknown | undefined;
    	findCorrespondingLeaf(): WorkspaceLeaf | null;
    	getHeadings(): string[];
    	getOwner(): View | null;
    	getViewType(): typeof ViewType.Outline;
    	handleCollapseAll(e: unknown): void;
    	handleSelectionChange(): void;
    	onFileChanged(file: TFile): void;
    	onMarkdownScroll(e: unknown): void;
    	onToggleShowSearch(): void;
    	setHighlightedItem(e: unknown): void;
    	setShowSearch(e: unknown): void;
    	showSearch(): void;
    	update(): void;
    	updateSearch(): void;
}

// @public
export interface OutlineViewConstructor extends TypedViewConstructor<OutlineView, [
	outlinePluginInstance: OutlinePluginInstance
]> {
}

// @public
export interface PagePreviewPlugin extends InternalPlugin<PagePreviewPluginInstance> {
}

// @public
export interface PagePreviewPluginInstance extends InternalPluginInstance<PagePreviewPlugin> {
    	app: App;
    	defaultOn: true;
}

// @public
export function parentFolderPath(path: string): string;

// @public
export interface PdfExportSettings {
    	downscalePercent: number;
    	landscape: boolean;
    	margin: string;
    	pageSize: string;
}

// @public
export interface PdfJsTestingUtils {
    	HighlightOutliner: HighlightOutliner;
}

// @public
export interface PdfView extends EditableFileView {
    	getViewType(): typeof ViewType.Pdf;
    	onModify(file: TFile): void;
    	showSearch(): void;
    	viewer: unknown;
}

// @public
export interface PdfViewConstructor extends TypedViewConstructor<PdfView> {
}

// @public
export interface PlatformEx {
    	canDisplayRibbon: boolean;
    	canExportPdf: boolean;
    	canPopoutWindow: boolean;
    	canSplit: boolean;
    	canStackTabs: boolean;
    	isAndroidApp: boolean;
    	isDesktop: boolean;
    	isDesktopApp: boolean;
    	isIosApp: boolean;
    	isLinux: boolean;
    	isMacOS: boolean;
    	isMobile: boolean;
    	isMobileApp: boolean;
    	isPhone: boolean;
    	isSafari: boolean;
    	isTablet: boolean;
    	isWin: boolean;
    	mobileDeviceHeight: number;
    	mobileKeyboardHeight: number;
    	mobileSoftKeyboardVisible: boolean;
    	resourcePathPrefix: string;
}

// @public
export interface Plugins {
    	app: App;
    	checkForDeprecations(): Promise<void>;
    	checkForUpdates(): Promise<void>;
    	disablePlugin(id: string): Promise<void>;
    	disablePluginAndSave(id: string): Promise<void>;
    	enabledPlugins: Set<string>;
    	enablePlugin(id: string): Promise<void>;
    	enablePluginAndSave(id: string): Promise<void>;
    	getPlugin(id: string): Plugin_2 | null;
    	getPluginFolder(): string;
    	initialize(): Promise<void>;
    	installPlugin(repo: string, version: string, manifest: PluginManifest): Promise<void>;
    	isDeprecated(id: string): boolean;
    	isEnabled(): boolean;
    	loadingPluginId: string | null;
    	loadManifest(path: string): Promise<void>;
    	loadManifests(): Promise<void>;
    	loadPlugin(id: string): Promise<Plugin_2>;
    	manifests: PluginsManifestsRecord;
    	onRaw(e: unknown): void;
    	plugins: PluginsPluginsRecord;
    	requestSaveConfig: Debouncer<[
    	], Promise<void>>;
    	saveConfig(): Promise<void>;
    	setEnable(enabled: boolean): Promise<void>;
    	uninstallPlugin(id: string): Promise<void>;
    	unloadPlugin(id: string): Promise<void>;
    	updates: Map<string, PluginUpdateManifest>;
}

// @public
export interface PluginsManifestsRecord extends Record<string, PluginManifest> {
}

// @public
export interface PluginsPluginsRecord extends Record<string, Plugin_2> {
}

// @public
export interface PluginUpdateManifest {
    	manifest: PluginManifest;
    	repo: string;
    	version: string;
}

// @public
export interface Pointer {
    	x: number;
    	y: number;
}

// @public
export interface PositionedReference extends Reference, CacheItem {
}

// @public
export interface PowerTag {
    	clearGraphics(): void;
    	getTextStyle(): TextStyle;
    	initGraphics(): void;
    	render(): void;
    	rendered: boolean;
    	renderer: GraphRenderer;
    	text: Text_2;
}

// @public
export interface PromisedQueue {
    	promise: Promise<unknown>;
    	queue<T>(fn: () => T | Promise<T>): Promise<T>;
}

// @public
export interface PropertiesPlugin extends InternalPlugin<PropertiesPluginInstance> {
}

// @public
export interface PropertiesPluginInstance extends InternalPluginInstance<PropertiesPlugin> {
    	app: App;
    	defaultOn: false;
    	plugin: PropertiesPlugin;
}

// @public
export interface PropertyEntryData<T> {
    	key: string;
    	type: string;
    	value: T;
}

// @public
export interface PropertyInfo {
    	name: string;
    	occurrences: number;
    	widget: string;
}

// @public
export interface PropertyPropertyWidgetComponent extends PropertyWidgetComponentBase {
    	combobox: PropertyPropertyWidgetComponentComboBox;
    	inputEl: HTMLInputElement;
    	type: "property";
}

// @public
export interface PropertyPropertyWidgetComponentComboBox extends PopoverSuggest<PropertyPropertyWidgetComponentComboBoxItem> {
    	attachDom(): void;
    	bgEl: HTMLDivElement;
    	buttonEl: HTMLDivElement;
    	clearable: boolean;
    	detachDom(): Promise<void>;
    	focus(): void;
    	getItems(): PropertyPropertyWidgetComponentComboBoxItem[];
    	getSuggestions(query: string): SearchResult[];
    	iconEl: HTMLDivElement;
    	_items: PropertyPropertyWidgetComponentComboBoxItem[];
    	labelEl: HTMLDivElement;
    	onClose(callback: () => void): this;
    	_onClose?(): void;
    	onInputChange(query: string): void;
    	onOpen(callback: () => void): this;
    	_onOpen?(): void;
    	onSelect(callback: (item: PropertyPropertyWidgetComponentComboBoxItem) => void): this;
    	renderLabel(): void;
    	searchComponent: SearchComponent;
    	selectCb?(item: PropertyPropertyWidgetComponentComboBoxItem): void;
    	setClearable(clearable: boolean): this;
    	setItems(items: PropertyPropertyWidgetComponentComboBoxItem[]): this;
    	setPlaceholder(placeholder: string): this;
    	setValue(value: PropertyPropertyWidgetComponentComboBoxItem): this;
    	setValueById(id: string): this;
    	toggle(): unknown;
    	updateValue(value: PropertyPropertyWidgetComponentComboBoxItem): this;
    	value: PropertyPropertyWidgetComponentComboBoxItem | null;
}

// @public
export interface PropertyPropertyWidgetComponentComboBoxItem {
    	icon: string;
    	value: string;
}

// @public
export interface PropertyRenderContext {
    	app: App;
    	blur(): void;
    	key: string;
    	onChange(value: unknown): void;
    	sourcePath: string;
}

// @public
export interface PropertyWidget<ComponentType extends PropertyWidgetComponentBase = PropertyWidgetComponentBase> {
    	icon: string;
    	name(): string;
    	render(containerEl: HTMLElement, data: unknown, context: PropertyRenderContext): ComponentType;
    	reservedKeys?: string[];
    	type: string;
    	validate(value: unknown): boolean;
}

// @public
export interface PropertyWidgetComponentBase {
    	containerEl: HTMLElement;
    	focus(mode?: FocusMode): void;
    	onFocus(mode: FocusMode): void;
    	setValue(value: unknown): void;
    	type: string;
}

// @public
export interface PropertyWidgetEntry {
    	name: string;
    	widget: PropertyWidgetType;
}

// @public
export type PropertyWidgetType = "aliases" | "checkbox" | "date" | "datetime" | "multitext" | "number" | "tags" | "text" | string;

// @public
export interface PublishPlugin extends InternalPlugin<PublishPluginInstance> {
}

// @public
export interface PublishPluginInstance extends InternalPluginInstance<PublishPlugin> {
    	app: App;
    	plugin: PublishPlugin;
}

// @public
export interface QueryForFuzzySearch {
    	fuzzy: string[];
    	query: string;
    	tokens: string[];
}

// @public
export interface RandomNotePlugin extends InternalPlugin<RandomNotePluginInstance> {
}

// @public
export interface RandomNotePluginInstance extends InternalPluginInstance<RandomNotePlugin> {
    	app: App;
}

// @public
export interface ReadViewRenderer {
    	addBottomPadding: boolean;
    	asyncSections: unknown[];
    	clear(): void;
    	lastRender: number;
    	lastScroll: number;
    	lastText: string;
    	parseAsync(): void;
    	parseSync(): void;
    	previewEl: HTMLElement;
    	pusherEl: HTMLElement;
    	queueRender(): void;
    	recycledSections: unknown[];
    	rendered: unknown[];
    	sections: RendererSection[];
    	set(text: string): void;
    	text: string;
}

// @public
export interface RecentFileTracker {
    	collect(file: TFile): void;
    	getLastOpenFiles(): string[];
    	getRecentFiles(options?: GetRecentFilesOptions): string[];
    	lastOpenFiles: string[];
    	load(savedFiles: string[]): void;
    	onFileCreated(file: TFile): void;
    	onFileOpen(prevFile: TFile, file: TFile): void;
    	onRename(file: TFile, oldPath: string): void;
    	serialize(): string[];
    	vault: Vault;
    	workspace: Workspace;
}

// @public
export interface ReleaseNotesView extends ItemView {
    	fetchReleaseNotes(version: string): Promise<unknown>;
    	getViewType(): typeof ViewType.ReleaseNotes;
    	render(): Promise<unknown>;
    	showPatchNotes(e: unknown, version: string): Promise<unknown>;
}

// @public
export interface ReleaseNotesViewConstructor extends TypedViewConstructor<ReleaseNotesView> {
}

// @public
export interface RenderContext {
}

// @public
export interface RendererSection {
    	el: HTMLElement;
    	html: string;
    	rendered: boolean;
}

// @public
export interface ResultDom {
    	addResult(file: TFile, result: ResultDomResult, content: string, shouldShowTitle?: boolean): ResultDomItem;
    	app: App;
    	changed: Debouncer<[
    	], unknown>;
    	changeFocusedItem(arg1: unknown): unknown;
    	childrenEl: HTMLDivElement;
    	collapseAll: boolean;
    	el: HTMLDivElement;
    	emptyResults(): unknown;
    	emptyStateEl: HTMLDivElement;
    	extraContext: boolean;
    	focusedItem: null;
    	getFiles(): unknown;
    	getMatchCount(): number;
    	getResult(arg1: unknown): unknown;
    	infinityScroll: InfinityScroll;
    	info: TreeNodeInfo;
    	onChange(): unknown;
    	onResize(): unknown;
    	pusherEl: HTMLDivElement;
    	removeResult(arg1: unknown): unknown;
    	resultDomLookup: Map<TFile, ResultDomItem>;
    	setCollapseAll(arg1: unknown): unknown;
    	setExtraContext(arg1: unknown): unknown;
    	setFocusedItem(arg1: unknown): unknown;
    	showingEmptyState: boolean;
    	sortOrder: string;
    	startLoader(): unknown;
    	stopLoader(): unknown;
    	toggle(arg1: unknown, arg2: unknown): Promise<unknown>;
    	vChildren: TreeNodeVChildren<ResultDomItem, ResultDom>;
    	working: boolean;
}

// @public
export interface ResultDomItem extends TreeNode {
    	app: App;
    	childrenEl: HTMLDivElement;
    	collapsed: boolean;
    	collapseEl: HTMLDivElement;
    	collapsible: boolean;
    	containerEl: HTMLDivElement;
    	content: string;
    	extraContext: boolean;
    	file: TFile;
    	getMatchExtraPositions(arg1: unknown, arg2: unknown, arg3: unknown): unknown;
    	info: TreeNodeInfo;
    	invalidate(): unknown;
    	onCollapseClick(arg1: unknown): unknown;
    	onMatchRender: null;
    	onResultClick(arg1: unknown): unknown;
    	onResultContextMenu(arg1: unknown): unknown;
    	onResultMouseover(arg1: unknown, arg2: unknown, arg3: unknown): unknown;
    	parent: ResultDom;
    	parentDom: ResultDom;
    	pusherEl: HTMLDivElement;
    	renderContentMatches(): void;
    	result: ResultDomResult;
    	separateMatches: boolean;
    	setCollapse(arg1: unknown, arg2: unknown): Promise<unknown>;
    	setCollapsible(arg1: unknown): unknown;
    	setExtraContext(arg1: unknown): unknown;
    	showTitle: boolean;
    	vChildren: TreeNodeVChildren<ResultDomItem, ResultDomItemChild>;
}

// @public
export interface ResultDomItemChild extends TreeNode {
    	cache: CachedMetadata;
    	content: string;
    	end: number;
    	getNextPos(arg1: unknown): number;
    	getPrevPos(arg1: unknown): number;
    	info: TreeNodeInfo;
    	matches: ContentPosition[];
    	mutateEState: unknown;
    	onFocusEnter(event?: UIEvent): void;
    	onFocusExit(event?: UIEvent): void;
    	onMatchRender: unknown;
    	onResultClick(event: UIEvent): void;
    	parent: ResultDomItem;
    	parentDom: ResultDomItem;
    	render(hasTextBefore: boolean, hasTextAfter: boolean): void;
    	showMoreAfter(): void;
    	showMoreAfterEl: HTMLElement;
    	showMoreBefore(): void;
    	showMoreBeforeEl: HTMLElement;
    	start: number;
    	toggleShowMoreContextButtons(): void;
}

// @public
export interface ResultDomResult {
    	content: ContentPosition[];
    	properties: ResultProperty[];
}

// @public
export interface ResultProperty {
    	key: string;
    	pos: ContentPosition;
    	subkey: (number | string)[];
}

// @public
export interface RibbonItem {
    	callback(): Promise<void>;
    	hidden: boolean;
    	icon: IconName;
    	id: string;
    	title: string;
}

// @public
export interface RoundFunction extends BasesFunction, HasGetDisplayName {
}

// @public
export interface Runnable {
    	cancel(): void;
    	cancelled: boolean;
    	isCancelled(): boolean;
    	isRunning(): boolean;
    	onCancel: null | (() => void);
    	onStart: null | (() => void);
    	onStop: null | (() => void);
    	running: boolean;
    	start(): void;
    	stop(): void;
}

// @public
export interface ScrollInfo {
    	clientHeight: number;
    	clientWidth: number;
    	height: number;
    	left: number;
    	top: number;
    	width: number;
}

// @public
export interface SearchBookmarkItem extends BookmarkItem {
    	query: string;
    	type: "search";
}

// @public
export interface SearchCursor {
    	current(): EditorRange;
    	findAll(): EditorRange[];
    	findNext(): EditorRange;
    	findPrevious(): EditorRange;
    	replace(replacement: string, origin: string): void;
    	replaceAll(replacement: string, origin: string): void;
}

// @public
export interface SearchView extends View {
    	getQuery(): string;
    	getViewType(): typeof ViewType.Search;
    	onCopyResultsClick(event: MouseEvent): void;
    	onKeyArrowDownInFocus(event: KeyboardEvent): void;
    	onKeyArrowLeftInFocus(event: KeyboardEvent): void;
    	onKeyArrowRightInFocus(event: KeyboardEvent): void;
    	onKeyArrowUpInFocus(event: KeyboardEvent): void;
    	onKeyEnterInFocus(event: KeyboardEvent): void;
    	onKeyShowMoreAfter(e: unknown): void;
    	onKeyShowMoreBefore(e: unknown): void;
    	onTabHeaderClick(): void;
    	renderSearchInfo(e: unknown, parentEl: HTMLElement): void;
    	saveSearch(): void;
    	setCollapseAll(e: unknown): void;
    	setExplainSearch(e: unknown): void;
    	setExtraContext(e: unknown): void;
    	setMatchingCase(e: unknown): void;
    	setQuery(value: string): void;
    	setSortOrder(sortOrder: unknown): void;
    	startSearch(): void;
    	stopSearch(): void;
    	toggleFilterSection(): void;
}

// @public
export interface SearchViewConstructor extends TypedViewConstructor<SearchView> {
}

// @public
export interface SecondFunction extends BasesFunction, HasExtract {
}

// @public
export interface SerializedBasesSubView {
    	name: string;
    	type: string;
}

// @public
export interface SerializedWorkspace {
    	active: string;
    	lastOpenFiles: string[];
    	left: LeafEntry;
    	leftRibbon: SerializedWorkspaceLeftRibbon;
    	main: LeafEntry;
    	right: LeafEntry;
}

// @public
export interface SerializedWorkspaceItem {
    	dimension?: number;
    	id: string;
    	type: string;
}

// @public
export interface SerializedWorkspaceLeafHistory {
    	backHistory: WorkspaceLeafHistoryState[];
    	forwardHistory: WorkspaceLeafHistoryState[];
}

// @public
export interface SerializedWorkspaceLeftRibbon {
    	hiddenItems: SerializedWorkspaceLeftRibbonHiddenItemsRecord;
}

// @public
export interface SerializedWorkspaceLeftRibbonHiddenItemsRecord extends Record<string, boolean> {
}

// @public
export interface SerializedWorkspaceSidedock extends SerializedWorkspaceItem {
    	collapsed: boolean;
    	width: number;
}

// @public
export interface SetBookmarkOptions {
    	insertLeft?: boolean;
}

// @public
export interface SetHighlightMatch {
    	endLoc?: number;
    	focus: boolean;
    	line?: number;
    	match?: unknown;
    	startLoc?: number;
}

// @public
export interface SetSelectionOptions {
    	origin?: string;
}

// @public
export interface SharedFile {
    	name: string;
    	uri: string;
}

// @public
export interface ShareReceiver {
    	app: App;
    	handleShareFiles(files: SharedFile[]): Promise<void>;
    	handleShareText(text: string): Promise<void>;
    	importFiles(files: SharedFile[]): Promise<void>;
    	setupNative(): void;
    	setupWorkspace(): void;
}

// @public
export interface SlashCommandPlugin extends InternalPlugin<SlashCommandPluginInstance> {
}

// @public
export interface SlashCommandPluginInstance extends InternalPluginInstance<SlashCommandPlugin> {
    	defaultOn: false;
}

// @public
export interface SliceFunction extends BasesFunction {
}

// @public
export interface SlidesPlugin extends InternalPlugin<SlidesPluginInstance> {
}

// @public
export interface SlidesPluginInstance extends InternalPluginInstance<SlidesPlugin> {
    	app: App;
}

// @public
export interface SQLError {
    	code: number;
    	message: string;
}

// @public
export interface SQLResultSet {
    	insertId: number;
    	rows: SQLResultSetRowList;
    	rowsAffected: number;
}

// @public
export interface SQLResultSetRowList {
    	item(index: number): unknown;
    	length: number;
}

// @public
export interface SQLTransaction {
    	executeSql(sqlStatement: string, arguments?: unknown[], callback?: (transaction: SQLTransaction, resultSet: SQLResultSet) => void, errorCallback?: (transaction: SQLTransaction, error: SQLError) => boolean): void;
}

// @public
export interface StateHistory {
    	eState: StateHistoryEphemeralState;
    	icon?: string;
    	leafHistory?: StateHistoryLeafHistory;
    	parentId?: string;
    	rootId?: string;
    	state: ViewState;
    	title?: string;
}

// @public
export interface StateHistoryEphemeralState {
    	cursor: EditorRange;
    	scroll: number;
}

// @public
export interface StateHistoryLeafHistory {
    	backHistory: StateHistory[];
    	forwardHistory: StateHistory[];
}

// @public
export interface StatusBar {
    	app: App;
    	containerEl: HTMLElement;
}

// @public
export interface Submenu {
    	icon: string;
    	title: string;
}

// @public
export interface SuggestionContainer<T> {
    	addMessage(text: string): HTMLElement;
    	addSuggestion(suggestion: SearchResult): void;
    	chooser: EditorSuggest<T>;
    	containerEl: HTMLElement;
    	forceSetSelectedItem(index: number, event: Event): void;
    	getSelectedElement(): HTMLElement | null;
    	getSelectedValue(): SearchResult | null;
    	moveDown(event: KeyboardEvent): boolean;
    	moveUp(event: KeyboardEvent): boolean;
    	get numVisibleItems(): number;
    	onSuggestionClick(event: MouseEvent, element: HTMLElement): void;
    	onSuggestionMouseover(event: MouseEvent, element: HTMLElement): unknown;
    	pageDown(event: KeyboardEvent): boolean;
    	pageUp(event: KeyboardEvent): boolean;
    	get rowHeight(): number;
    	selectedItem: number;
    	setSelectedItem(index: number, event: Event): void;
    	setSuggestions(suggestions: SearchResult[]): void;
    	suggestions: HTMLElement[];
    	useSelectedItem(event: Event): boolean;
    	values: SearchResult[];
}

// @public
export interface SuggestModalChooser<T, TModal> {
    	addMessage(text: string | DocumentFragment): void;
    	addSuggestion(value: T): void;
    	chooser: TModal;
    	containerEl: HTMLDivElement;
    	forceSetSelectedItem(index: number, evt: MouseEvent | KeyboardEvent): void;
    	moveDown(evt: KeyboardEvent): false | void;
    	moveUp(evt: KeyboardEvent): false | void;
    	numVisibleItems: number;
    	onSuggestionClick(evt: MouseEvent, suggestion: HTMLDivElement): void;
    	onSuggestionMouseover(evt: MouseEvent, suggestion: HTMLDivElement): void;
    	pageDown(evt: KeyboardEvent): false | void;
    	pageUp(evt: KeyboardEvent): false | void;
    	rowHeight: number;
    	selectedItem: number;
    	setSelectedItem(index: number, evt: MouseEvent | KeyboardEvent): void;
    	setSuggestions(values: T[] | null): void;
    	suggestions: HTMLDivElement[];
    	useSelectedItem(evt: MouseEvent | KeyboardEvent): void;
    	values: T[] | null;
}

// @public
export interface SwitcherPlugin extends InternalPlugin<SwitcherPluginInstance> {
}

// @public
export interface SwitcherPluginInstance extends InternalPluginInstance<SwitcherPlugin> {
    	app: App;
    	defaultOn: true;
    	plugin: SwitcherPlugin;
}

// @public
export interface SyncPlugin extends InternalPlugin<SyncPluginInstance> {
}

// @public
export interface SyncPluginInstance extends InternalPluginInstance<SyncPlugin> {
    	app: App;
    	plugin: SyncPlugin;
}

// @public
export interface SyncView extends View {
    	getViewType(): typeof ViewType.Sync;
}

// @public
export interface SyncViewConstructor extends TypedViewConstructor<SyncView, [
	syncPluginInstance: SyncPluginInstance
]> {
}

// @public
export interface TableCell {
    	col: number;
    	contentEl: HTMLElement;
    	dirty: boolean;
    	el: HTMLElement;
    	end: number;
    	padEnd: number;
    	padStart: number;
    	row: number;
    	start: number;
    	table: TableCellEditor;
    	text: string;
}

// @public
export interface TableCellEditor extends MarkdownBaseView, TableCell {
}

// @public
export interface TableEditor {
}

// @public
export interface TableView extends View {
    	getViewType(): typeof ViewType.Table;
}

// @public
export interface TableViewConstructor extends ConstructorBase<[
	app: App,
	containerEl: HTMLElement
], TableView> {
}

// @public
export interface TaggedWithFunction extends BasesFunction, HasGetDisplayName, HasGetRHSWidgetType {
}

// @public
export interface TagPanePlugin extends InternalPlugin<TagPanePluginInstance> {
}

// @public
export interface TagPanePluginInstance extends InternalPluginInstance<TagPanePlugin> {
    	app: App;
    	defaultOn: true;
    	plugin: TagPanePlugin;
}

// @public
export interface TagsPropertyWidgetComponent extends PropertyWidgetComponentBase {
    	multiselect: Multiselect;
    	type: "tags";
}

// @public
export interface TagView extends View {
    	getNodeId(e: unknown): unknown;
    	getViewType(): typeof ViewType.Tag;
    	isItem(item: unknown): boolean;
    	onKeyEnterInFocus(event: KeyboardEvent): void;
    	setIsAllCollapsed(e: unknown): void;
    	setUseHierarchy(e: unknown): void;
    	updateTags(): void;
}

// @public
export interface TagViewConstructor extends TypedViewConstructor<TagView> {
}

// @public
export interface TemplatesPlugin extends InternalPlugin<TemplatesPluginInstance> {
}

// @public
export interface TemplatesPluginInstance extends InternalPluginInstance<TemplatesPlugin> {
    	app: App;
    	defaultOn: true;
    	plugin: TemplatesPlugin;
}

// @public
export type TextDirection = "auto" | "ltr" | "rtl";

// @public
export interface TextPropertyWidgetComponent extends PropertyWidgetComponentBase {
    	ctx: PropertyRenderContext;
    	getDisplayText(): string;
    	getLinkText(): string;
    	inputEl: HTMLInputElement;
    	isAlias(): boolean;
    	isWikilink(): boolean;
    	linkEl: HTMLDivElement;
    	linkTextEl: HTMLDivElement;
    	render(): void;
    	type: "text";
    	value: string;
}

// @public
export interface TFileConstructor extends ConstructorBase<[
	vault: Vault,
	path: string
], TFile> {
}

// @public
export interface TFolderConstructor extends ConstructorBase<[
	vault: Vault,
	path: string
], TFolder> {
}

// @public
export interface ThemeManifest {
    	author: string;
    	authorUrl?: string;
    	dir: string;
    	fundingUrl?: string;
    	minAppVersion: string;
    	name: string;
    	version: "0.0.0" | string;
}

// @public
export interface TitleFunction extends BasesFunction {
}

// @public
export interface Token extends EditorRange {
    	text: string;
    	type: "tag" | "external-link" | "internal-link";
}

// @public
export interface Tree<T extends TreeItem> {
    	activeDom: T | null;
    	app: App;
    	changeFocusedItem(direction: "forwards" | "backwards"): void;
    	clearSelectedDoms(): void;
    	containerEl: HTMLElement;
    	deselectItem(node: T): void;
    	focusedItem: T | null;
    	getFoldKey(): string;
    	getNodeId(node: T): string | undefined;
    	handleCollapseAll: () => void;
    	handleDeleteSelectedItems(event: KeyboardEvent): Promise<void>;
    	handleItemSelection(event: MouseEvent, node: T): void;
    	handleRenameFocusedItem: (event: KeyboardEvent) => void;
    	id: string;
    	infinityScroll: InfinityScroll;
    	initializeKeyboardNav(): void;
    	isAllCollapsed: boolean;
    	isItem(node: T | undefined): boolean;
    	loadFolds(): void;
    	onKeyArrowDown(event: KeyboardEvent): void;
    	onKeyArrowLeft(event: KeyboardEvent): void;
    	onKeyArrowRight(event: KeyboardEvent): void;
    	onKeyArrowUp(event: KeyboardEvent): void;
    	onKeyOpen(event: KeyboardEvent): void;
    	onResize(): void;
    	prefersCollapsed: boolean;
    	requestSaveFolds: () => void;
    	get root(): TreeRoot<T>;
    	saveFolds(): void;
    	scope: Scope;
    	selectedDoms: Set<T>;
    	selectItem(node: T): void;
    	setCollapseAll(collapse: boolean): void;
    	setFocusedItem(node: T, scrollIntoView?: boolean): void;
    	toggleCollapseAll(): void;
    	view: View;
}

// @public
export interface TreeCollapsibleItem extends TreeItem {
    	childrenEl: HTMLElement;
    	collapsed: boolean;
    	collapseEl: HTMLElement | null;
    	collapsible: boolean;
    	onCollapseClick(event: MouseEvent): void;
    	setCollapsed(value: boolean, animate?: boolean): Promise<undefined>;
    	setCollapsible(value: boolean): void;
    	toggleCollapsed(animate?: boolean): Promise<undefined>;
    	updateCollapsed(animate?: boolean): Promise<undefined>;
}

// @public
export interface TreeItem extends TreeNode {
    	coverEl: HTMLElement;
    	innerEl: HTMLElement;
    	onSelfClick(event: MouseEvent): void;
    	selfEl: HTMLElement;
    	setClickable(value: boolean): void;
}

// @public
export interface TreeNode {
    	el: HTMLElement;
}

// @public
export interface TreeNodeInfo {
    	childLeft: number;
    	childLeftPadding: number;
    	childTop: number;
    	computed: boolean;
    	height: number;
    	hidden: boolean;
    	next: boolean;
    	queued: boolean;
    	width: number;
}

// @public
export interface TreeNodeVChildren<Item extends TreeNode, Owner extends TreeNode> {
    	addChild(item: Item): void;
    	get children(): Item[];
    	_children: Item[];
    	clear(): void;
    	first(): Item | undefined;
    	hasChildren(): boolean;
    	last(): Item | undefined;
    	owner: Owner;
    	removeChild(item: Item): void;
    	setChildren(children: Item[]): void;
    	size(): number;
    	sort(compareFn: (a: Item, b: Item) => number): void;
}

// @public
export interface TreeRoot<Item extends TreeItem> extends TreeNode {
    	childrenEl: HTMLElement;
    	info: TreeNodeInfo;
    	pusherEl: HTMLElement;
    	vChildren: TreeNodeVChildren<Item, TreeRoot<Item>>;
}

// @public
export interface TrimFunction extends BasesFunction {
}

// @public
export interface TypedViewConstructor<TView extends View, Args extends unknown[] = [
]> extends ConstructorBase<[
	leaf: WorkspaceLeaf,
	...args: Args
], TView> {
}

// @public
export type TypedViewCreator<TView extends View> = (leaf: WorkspaceLeaf) => TView;

// @public
export interface TypedWorkspaceLeaf<TView extends View> extends WorkspaceLeaf {
    	view: MaybeDeferredView<TView>;
}

// @public
export interface TypeInfo {
    	expected: PropertyWidget;
    	inferred: PropertyWidget;
}

// @public
export interface UniqueFunction extends BasesFunction {
}

// @public
export interface UnknownPropertyWidgetComponent extends PropertyWidgetComponentBase {
    	el: HTMLSpanElement;
    	type: "unknown";
}

// @public
export interface UnknownView extends EmptyView {
}

// @public
export interface UrlBookmarkItem extends BookmarkItem {
    	title: string;
    	type: "url";
    	url: string;
}

// @public
export interface VaultFileMapRecord extends Record<string, TAbstractFile> {
}

// @public
export interface VideoView extends EditableFileView {
    	getViewType(): typeof ViewType.Video;
}

// @public
export interface VideoViewConstructor extends TypedViewConstructor<VideoView> {
}

// @public
export interface ViewEphemeralState {
    	cursor?: EditorRangeOrCaret;
    	focus: boolean;
    	focusOnMobile: boolean;
}

// @public
export type ViewFactory<TView extends View = View> = (containerEl: HTMLElement) => TView;

// @public
export interface ViewRegistry extends Events {
    	getTypeByExtension(extension: string): string | undefined;
    	getViewCreatorByType(type: string): ViewCreator | undefined;
    	getViewCreatorByType<TViewType extends ViewTypeType>(type: TViewType): TypedViewCreator<ViewTypeViewMapping[TViewType]> | undefined;
    	isExtensionRegistered(extension: string): boolean;
    	on(name: "extensions-updated", callback: () => void): EventRef;
    	on(name: "view-registered", callback: (type: string) => void): EventRef;
    	on(name: "view-unregistered", callback: (type: string) => void): EventRef;
    	registerExtensions(extension: string[], type: string): void;
    	registerView(type: string, viewCreator: ViewCreator): void;
    	registerViewWithExtensions(extensions: string[], type: string, viewCreator: ViewCreator): void;
    	typeByExtension: ViewRegistryTypeByExtensionRecord;
    	unregisterExtensions(extension: string[]): void;
    	unregisterView(type: string): void;
    	viewByType: ViewRegistryViewByTypeRecord;
}

// @public
export interface ViewRegistryTypeByExtensionRecord extends Record<string, string> {
    	[FileExtension._3gp]: typeof ViewType.Audio;
    	[FileExtension.avif]: typeof ViewType.Image;
    	[FileExtension.bmp]: typeof ViewType.Image;
    	[FileExtension.canvas]: typeof ViewType.Canvas;
    	[FileExtension.flac]: typeof ViewType.Audio;
    	[FileExtension.gif]: typeof ViewType.Image;
    	[FileExtension.jpeg]: typeof ViewType.Image;
    	[FileExtension.jpg]: typeof ViewType.Image;
    	[FileExtension.m4a]: typeof ViewType.Audio;
    	[FileExtension.md]: typeof ViewType.Markdown;
    	[FileExtension.mkv]: typeof ViewType.Video;
    	[FileExtension.mov]: typeof ViewType.Video;
    	[FileExtension.mp3]: typeof ViewType.Audio;
    	[FileExtension.mp4]: typeof ViewType.Video;
    	[FileExtension.oga]: typeof ViewType.Audio;
    	[FileExtension.ogg]: typeof ViewType.Audio;
    	[FileExtension.ogv]: typeof ViewType.Video;
    	[FileExtension.opus]: typeof ViewType.Audio;
    	[FileExtension.pdf]: typeof ViewType.Pdf;
    	[FileExtension.png]: typeof ViewType.Image;
    	[FileExtension.svg]: typeof ViewType.Image;
    	[FileExtension.wav]: typeof ViewType.Audio;
    	[FileExtension.webm]: typeof ViewType.Video;
    	[FileExtension.webp]: typeof ViewType.Image;
}

// @public
export interface ViewRegistryViewByTypeRecord extends Record<string, ViewCreator>, Mapping {
}

// @public
export const ViewType: {
    	readonly AllProperties: "all-properties";
    	readonly Audio: "audio";
    	readonly Backlink: "backlink";
    	readonly Bases: "bases";
    	readonly Bookmarks: "bookmarks";
    	readonly Canvas: "canvas";
    	readonly Empty: "empty";
    	readonly FileExplorer: "file-explorer";
    	readonly FileProperties: "file-properties";
    	readonly Graph: "graph";
    	readonly Image: "image";
    	readonly LocalGraph: "localgraph";
    	readonly Markdown: "markdown";
    	readonly OutgoingLink: "outgoing-link";
    	readonly Outline: "outline";
    	readonly Pdf: "pdf";
    	readonly ReleaseNotes: "release-notes";
    	readonly Search: "search";
    	readonly Sync: "sync";
    	readonly Table: "table";
    	readonly Tag: "tag";
    	readonly Video: "video";
    	readonly Webviewer: "webviewer";
    	readonly WebviewerHistory: "webviewer-history";
};

// @public
export type ViewTypeType = (typeof ViewType)[keyof typeof ViewType];

// @public
export type ViewTypeViewConstructorMapping = {
    	[ViewType.AllProperties]: AllPropertiesViewConstructor;
    	[ViewType.Audio]: AudioViewConstructor;
    	[ViewType.Backlink]: BacklinkViewConstructor;
    	[ViewType.Bases]: BasesViewConstructor;
    	[ViewType.Bookmarks]: BookmarksViewConstructor;
    	[ViewType.Webviewer]: WebviewerViewConstructor;
    	[ViewType.WebviewerHistory]: WebviewerHistoryViewConstructor;
    	[ViewType.Canvas]: CanvasViewConstructor;
    	[ViewType.Empty]: EmptyViewConstructor;
    	[ViewType.FileExplorer]: FileExplorerViewConstructor;
    	[ViewType.FileProperties]: FilePropertiesViewConstructor;
    	[ViewType.Graph]: GraphViewConstructor;
    	[ViewType.Image]: ImageViewConstructor;
    	[ViewType.LocalGraph]: LocalGraphViewConstructor;
    	[ViewType.Markdown]: MarkdownViewConstructor;
    	[ViewType.OutgoingLink]: OutgoingLinkViewConstructor;
    	[ViewType.Outline]: OutlineViewConstructor;
    	[ViewType.Pdf]: PdfViewConstructor;
    	[ViewType.ReleaseNotes]: ReleaseNotesViewConstructor;
    	[ViewType.Search]: SearchViewConstructor;
    	[ViewType.Sync]: SyncViewConstructor;
    	[ViewType.Table]: TableViewConstructor;
    	[ViewType.Tag]: TagViewConstructor;
    	[ViewType.Video]: VideoViewConstructor;
};

// @public
export type ViewTypeViewMapping = {
    	[ViewType.AllProperties]: AllPropertiesView;
    	[ViewType.Audio]: AudioView;
    	[ViewType.Backlink]: BacklinkView;
    	[ViewType.Bases]: BasesView;
    	[ViewType.Bookmarks]: BookmarksView;
    	[ViewType.Webviewer]: WebviewerView;
    	[ViewType.WebviewerHistory]: WebviewerHistoryView;
    	[ViewType.Canvas]: CanvasView;
    	[ViewType.Empty]: EmptyView;
    	[ViewType.FileExplorer]: FileExplorerView;
    	[ViewType.FileProperties]: FilePropertiesView;
    	[ViewType.Graph]: GraphView;
    	[ViewType.Image]: ImageView;
    	[ViewType.LocalGraph]: LocalGraphView;
    	[ViewType.Markdown]: MarkdownView;
    	[ViewType.OutgoingLink]: OutgoingLinkView;
    	[ViewType.Outline]: OutlineView;
    	[ViewType.Pdf]: PdfView;
    	[ViewType.ReleaseNotes]: ReleaseNotesView;
    	[ViewType.Search]: SearchView;
    	[ViewType.Sync]: SyncView;
    	[ViewType.Table]: TableView;
    	[ViewType.Tag]: TagView;
    	[ViewType.Video]: VideoView;
};

// @public
export interface VimApi {
    	buildKeyMap(): void;
    	defineAction(name: string, fn: (cm: VimEditor, actionArgs: unknown, vim: VimState["vim"]) => void): void;
    	defineEx(name: unknown, prefix: unknown, func: unknown): unknown;
    	defineMotion(name: unknown, fn: unknown): unknown;
    	defineOperator(name: unknown, fn: unknown): unknown;
    	defineOption(name: unknown, defaultValue: unknown, type: unknown, aliases: unknown, callback: unknown): unknown;
    	defineRegister(name: unknown, register: unknown): unknown;
    	enterInsertMode(cm: unknown): unknown;
    	enterVimMode(cm: unknown): unknown;
    	exitInsertMode(cm: unknown, keepCursor: unknown): unknown;
    	exitVisualMode(cm: unknown, moveHead: unknown): unknown;
    	findKey(cm: unknown, key: unknown, origin: unknown): unknown;
    	getOption(name: unknown, cm: unknown, cfg: unknown): unknown;
    	getRegisterController(): unknown;
    	getVimGlobalState_(): unknown;
    	handleEx(cm: unknown, input: unknown): unknown;
    	handleKey(cm: unknown, key: unknown, origin: unknown): unknown;
    	InsertModeKey(keyName: string): void;
    	leaveVimMode(cm: unknown): unknown;
    	map(lhs: unknown, rhs: unknown, ctx: unknown): unknown;
    	mapclear(ctx: unknown): unknown;
    	mapCommand(keys: unknown, type: unknown, name: unknown, args: unknown, extra: unknown): unknown;
    	_mapCommand(command: unknown): unknown;
    	maybeInitVimState_(cm: unknown): unknown;
    	multiSelectHandleKey(cm: unknown, key: unknown, origin: unknown): unknown;
    	noremap(lhs: unknown, rhs: unknown, ctx: unknown): unknown;
    	resetVimGlobalState_(): unknown;
    	setOption(name: unknown, value: unknown, cm: unknown, cfg: unknown): unknown;
    	suppressErrorLogging: boolean;
    	unmap(lhs: unknown, ctx: unknown): unknown;
}

// @public
export interface VimEditor {
    	state: VimState;
}

// @public
export interface VimState {
    	vim: VimStateVim;
    	vimPlugin: VimStateVimPlugin;
}

// @public
export interface VimStateVim {
    	inputState: VimStateVimInputState;
    	insertMode: false;
    	insertModeRepeat: undefined;
    	lastEditActionCommand: undefined;
    	lastEditInputState: undefined;
    	lastHPos: number;
    	lastHSPos: number;
    	lastMotion: VimStateVimLastMotion;
    	lastPastedText: null;
    	lastSelection: null;
}

// @public
export interface VimStateVimInputState {
    	changeQueue: null;
    	keyBuffer: [
    	];
    	motion: null;
    	motionArgs: null;
    	motionRepeat: [
    	];
    	operator: null;
    	operatorArgs: null;
    	prefixRepeat: [
    	];
    	registerName: null;
}

// @public
export interface VimStateVimLastMotion {
    	name?: string;
}

// @public
export interface VimStateVimPlugin {
    	lastKeydown: string;
}

// @public
export interface WeakMapWrapper<K extends object, V> extends WeakMap<K, V> {
    	map: WeakMap<K, V>;
}

// @public
export interface WebviewerDBStore {
    	addHistoryItem(url: string, title?: string): Promise<void>;
    	app: App;
    	clearHistoryItems(): Promise<void>;
    	connect(): Promise<void>;
    	db: IDBDatabase;
    	getHistoryItems(): Promise<WebviewerHistoryItem[]>;
    	loadIcon(domain: string, source?: string): Promise<string | null>;
    	removeHistoryItem(item: WebviewerHistoryItem): Promise<void>;
    	setIcon(el: HTMLElement, url: string, source?: string): Promise<void>;
    	storeIcon(domain: string, source?: string): Promise<string | null>;
}

// @public
export interface WebviewerHistoryItem {
    	accessTs: number;
    	id: number;
    	title: string;
    	url: string;
}

// @public
export interface WebviewerHistoryView extends ItemView {
    	getViewType(): typeof ViewType.WebviewerHistory;
    	update(): Promise<unknown>;
}

// @public
export interface WebviewerHistoryViewConstructor extends TypedViewConstructor<WebviewerHistoryView, [
	browserPluginInstance: WebviewerPluginInstance
]> {
}

// @public
export interface WebviewerPlugin extends InternalPlugin<WebviewerPluginInstance> {
}

// @public
export interface WebviewerPluginInstance extends InternalPluginInstance<WebviewerPlugin> {
    	db: WebviewerDBStore;
    	defaultOn: false;
    	getSearchEngineUrl(searchQuery: string): string;
    	handleOpenUrl(event: CustomEvent<{
        		url: string;
        		newLeaf?: PaneType | boolean;
        		active?: boolean;
        	}>): void;
    	openUrl(url: string, newLeaf?: PaneType | boolean, active?: boolean): void;
    	openUrlExternally(url: string): void;
    	pendingIgnoredURLs: string[];
    	updateSession(): void;
}

// @public
export interface WebviewerView extends ItemView {
    	closeSearch(): void;
    	commitPageLoad(): unknown;
    	configureWebContents(): void;
    	contextMenuItemsForImg(e: unknown): unknown;
    	contextMenuItemsForLink(e: unknown, t: unknown): unknown;
    	contextMenuItemsForSelection(e: unknown, t: unknown): unknown;
    	displayBlank(): void;
    	displayContextMenu(e: unknown): void;
    	displayErrorView(): void;
    	displayReaderView(): Promise<unknown>;
    	displayWebView(): void;
    	getReaderModeContent(): Promise<unknown>;
    	getViewType(): typeof ViewType.Webviewer;
    	hideAll(): void;
    	instantiateWebView(): void;
    	navigate(e: unknown, t: unknown): unknown;
    	onCheckboxClick(e: unknown, t: unknown, n: unknown): void;
    	onExternalLinkClick(e: unknown, t: unknown, n: unknown): void;
    	onExternalLinkRightClick(e: unknown, t: unknown, n: unknown): void;
    	onFoldChange(): void;
    	onInternalLinkClick(e: unknown, t: unknown, n: unknown): void;
    	onInternalLinkDrag(e: unknown, t: unknown, n: unknown): void;
    	onInternalLinkMouseover(e: unknown, t: unknown, n: unknown): void;
    	onInternalLinkRightClick(e: unknown, t: unknown, n: unknown): void;
    	onReaderModeContextMenu(e: unknown): void;
    	onRenderComplete(): void;
    	onScroll(): void;
    	onTagClick(e: unknown, t: unknown, n: unknown): void;
    	postProcess(e: unknown, t: unknown, n: unknown): void;
    	pushViewStackHistory(e: unknown): void;
    	reportPageLoad(url: string, title: string, navigate: unknown): void;
    	saveAsMarkdown(): Promise<unknown>;
    	selectFavicon(e: unknown): unknown;
    	setFavicon(e: unknown): unknown;
    	showSearch(): void;
    	storeCurrentPageTitle(): Promise<unknown>;
    	toggleReaderMode(): void;
    	zoomIn(): void;
    	zoomOut(): void;
    	zoomReset(): void;
}

// @public
export interface WebviewerViewConstructor extends TypedViewConstructor<WebviewerView, [
	browserPluginInstance: WebviewerPluginInstance
]> {
}

// @public
export interface WidgetEditorView extends EmbeddedEditorView {
    	after: string;
    	applyScope(scope: Scope): void;
    	before: string;
    	data: string;
    	fileBeingRenamed: null | TFile;
    	getFoldInfo(): null | FoldInfo;
    	heading: string;
    	indent: string;
    	inlineTitleEl: HTMLElement;
    	lastSavedData: null | string;
    	loadContents(data: string, cache: CachedMetadata): void;
    	loadFile(): Promise<void>;
    	loadFileInternal(data: string, cache?: CachedMetadata): void;
    	onFileChanged(file: TFile, data: string, cache: CachedMetadata): void;
    	onFileRename(file: TAbstractFile, oldPath: string): void;
    	onload(): void;
    	onMarkdownFold(): void;
    	onTitleChange(element: HTMLElement): void;
    	onTitleKeydown(event: KeyboardEvent): void;
    	onTitlePaste(element: HTMLElement, event: ClipboardEvent): void;
    	onunload(): void;
    	save(data: string, delayed?: boolean): Promise<void>;
    	saveAgain: boolean;
    	saveTitle(element: HTMLElement): void;
    	saving: boolean;
    	showPreview(show?: boolean): void;
    	subpath: string;
    	subpathNotFound: boolean;
}

// @public
export interface WindowSelection {
    	focusEl: HTMLElement;
    	range: Range;
    	win: Window;
}

// @public
export interface WordCountPlugin extends InternalPlugin<WordCountPluginInstance> {
}

// @public
export interface WordCountPluginInstance extends InternalPluginInstance<WordCountPlugin> {
    	app: App;
    	defaultOn: true;
    	plugin: WordCountPlugin;
}

// @public
export interface WorkerResults {
    	buffer: SharedArrayBuffer;
    	id: number[];
    	v?: number;
}

// @public
export interface WorkspaceHoverLinkSourcesRecord extends Record<string, HoverLinkSource> {
}

// @public
export interface WorkspaceLeafHistory {
    	back(): Promise<void>;
    	backHistory: WorkspaceLeafHistoryState[];
    	deserialize(e: SerializedWorkspaceLeafHistory): void;
    	forward(): Promise<void>;
    	forwardHistory: WorkspaceLeafHistoryState[];
    	go(step: number): Promise<void>;
    	owner: WorkspaceLeaf;
    	pushState(state: WorkspaceLeafHistoryState): void;
    	serialize(): SerializedWorkspaceLeafHistory;
    	updateState(state: WorkspaceLeafHistoryState): Promise<void>;
}

// @public
export interface WorkspaceLeafHistoryState {
    	eState: unknown;
    	icon: IconName;
    	state: unknown;
    	title: string;
}

// @public
export interface WorkspacesPlugin extends InternalPlugin<WorkspacesPluginInstance> {
}

// @public
export interface WorkspacesPluginInstance extends InternalPluginInstance<WorkspacesPlugin> {
    	app: App;
    	plugin: WorkspacesPlugin;
}

// @public
export interface YearFunction extends BasesFunction, HasExtract {
}

// @public
export interface ZkPrefixerPlugin extends InternalPlugin<ZkPrefixerPluginInstance> {
}

// @public
export interface ZkPrefixerPluginInstance extends InternalPluginInstance<ZkPrefixerPlugin> {
    	app: App;
    	plugin: ZkPrefixerPlugin;
}

// (No @packageDocumentation comment for this package)

```
