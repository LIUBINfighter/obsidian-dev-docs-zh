import{_ as s,c as a,o as i,V as e}from"./chunks/framework.qP9-rlTe.js";const g=JSON.parse('{"title":"调试你的代码","description":"学习如何调试你的 Obsidian 插件代码。","frontmatter":{"title":"调试你的代码","description":"学习如何调试你的 Obsidian 插件代码。"},"headers":[],"relativePath":"zh/articles/typings/code-debugging.md","filePath":"zh/articles/typings/code-debugging.md","lastUpdated":1745515406000}'),n={name:"zh/articles/typings/code-debugging.md"},l=e(`<h1 id="debug" tabindex="-1">Debug! <a class="header-anchor" href="#debug" aria-label="Permalink to &quot;Debug!&quot;">​</a></h1><blockquote><p><a href="https://fevol.github.io/obsidian-typings/guides/code-debugging/" target="_blank" rel="noreferrer">Debugging your code | Obsidian Typings (fevol.github.io)</a></p></blockquote><h2 id="调试你的代码" tabindex="-1">调试你的代码 <a class="header-anchor" href="#调试你的代码" aria-label="Permalink to &quot;调试你的代码&quot;">​</a></h2><h3 id="展开代码跟踪" tabindex="-1">展开代码跟踪 <a class="header-anchor" href="#展开代码跟踪" aria-label="Permalink to &quot;展开代码跟踪&quot;">​</a></h3><p>有时你想要弄清楚代码在执行时的路径。这对于调查函数调用之间的不一致行为或在打包/压缩的代码中找到你的函数的确切位置很有帮助。</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 记录当前代码的堆栈跟踪，同时记录任何提供的参数</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * 在此处放置你的代码</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">trace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(var1, var2);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="断点" tabindex="-1">断点 <a class="header-anchor" href="#断点" aria-label="Permalink to &quot;断点&quot;">​</a></h3><p>像 IDE 一样，Chrome DevTools 提供了在特定代码行暂停的方法。以下是具体步骤：</p><ol><li>打开开发者工具（<code>Ctrl + Shift + I</code>）</li><li>转到 <code>Sources</code> 标签页</li><li>显示左侧栏（如果被隐藏）</li><li>在 <code>top &gt; obsidian.md &gt; plugin:XXX</code> 下选择你的插件代码</li><li>如果代码都在一行，点击 <code>Pretty format</code> 格式化</li><li>点击行号设置断点</li><li>运行代码启动调试器</li></ol><p><img src="https://fevol.github.io/obsidian-typings/_astro/devtools-breakpoint.BG7iqnjX_vProE.webp" alt="打开 DevTools 并设置断点"></p><p>注意：从控制台中的任何 <code>console.log</code>/<code>console.trace</code> 输出，你都可以直接跳转到转译文件中的对应位置</p><p>另外，你也可以通过代码添加断点：</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> yourFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在此处放置你的代码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  debugger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 作为断点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="调试" tabindex="-1">调试 <a class="header-anchor" href="#调试" aria-label="Permalink to &quot;调试&quot;">​</a></h3><p>如果你设置了断点并且代码被执行，调试器通常会暂停。在这种状态下，你可以做以下事情：</p><ol><li>跳转到下一行（<code>F10</code>）</li><li>步入函数（<code>F11</code>）或跳出函数（<code>Shift + F11</code>）</li><li>继续执行代码直到下一个断点（<code>F8</code>）</li><li>查看当前 <code>Scope</code> 中定义的值和参数</li><li>查看当前 <code>Call Stack</code></li><li>转到 <code>Console</code> 标签页，你可以测试和操作当前作用域中的值</li></ol><p><img src="https://fevol.github.io/obsidian-typings/_astro/devtools-breakpoint.BG7iqnjX_vProE.webp" alt="断点暂停时的可用选项"></p><h2 id="调查代码性能" tabindex="-1">调查代码性能 <a class="header-anchor" href="#调查代码性能" aria-label="Permalink to &quot;调查代码性能&quot;">​</a></h2><h3 id="计时你的代码" tabindex="-1">计时你的代码 <a class="header-anchor" href="#计时你的代码" aria-label="Permalink to &quot;计时你的代码&quot;">​</a></h3><p>假设你想看看代码运行需要多长时间，不用麻烦地使用 <code>Date.now()</code> 然后记录它，你可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/console" target="_blank" rel="noreferrer"><code>console API</code></a> 的内置命令：</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 测量代码执行时间并记录到控制台</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;label&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * 在此处放置你的耗时代码</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">timeEnd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;label&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="火焰图-🔥📈" tabindex="-1">火焰图（🔥📈） <a class="header-anchor" href="#火焰图-🔥📈" aria-label="Permalink to &quot;火焰图（🔥📈）&quot;">​</a></h3><p>如果你想要<em>更多</em>关于代码的信息，可以尝试生成火焰图。它显示所有触发的事件、执行的函数，并可视化程序的堆栈跟踪（包括由 web-workers 持有的单独线程）。</p><p>生成和显示火焰图：</p><ol><li>打开开发者工具（<code>Ctrl + Shift + I</code>）</li><li>转到 <code>Performance</code> 标签页（可能隐藏在箭头后面）</li><li>按下 <code>Record</code> 按钮或 <code>Ctrl + E</code>（devtools 标签页下最左边的按钮）</li><li>执行你的代码（可以是命令、渲染等） <em>（如果你的代码只在应用/插件启动时运行，你可以运行 <code>Reload app without saving</code> 命令而不停止捕获 - 为了方便可以为此操作创建快捷方式）</em></li><li>用同样的按钮或 <code>Ctrl + E</code> 停止记录</li><li>等待图表渲染 <img src="https://fevol.github.io/obsidian-typings/_astro/flame-chart-open.C6XSFKfo_ZRkEzM.webp" alt="打开 Performance 标签页并捕获火焰图"></li></ol><h3 id="使用火焰图" tabindex="-1">使用火焰图 <a class="header-anchor" href="#使用火焰图" aria-label="Permalink to &quot;使用火焰图&quot;">​</a></h3><p><code>Performance</code> 捕获中包含大量信息，以下是一些重要元素：</p><ol><li>如果启用了 <code>Screenshots</code> 选项（见顶部栏），你可以悬停在图片上查看应用在那个时刻的确切外观</li><li>在 <code>Main</code> 下，你可以看到随时间在主线程上执行的所有函数。 a) 高峰表示大量函数调用（深度嵌套） b) 宽块表示<strong>长执行时间</strong></li><li>放大图表以缩小时间间隔</li><li>点击图表中的块</li><li>...查看它是如何执行的信息 <img src="https://fevol.github.io/obsidian-typings/_astro/flame-chart-analyze.0uJbqCiZ_Z16YB3H.webp" alt="带有块信息的火焰图"></li></ol><h3 id="向火焰图添加标记" tabindex="-1">向火焰图添加标记 <a class="header-anchor" href="#向火焰图添加标记" aria-label="Permalink to &quot;向火焰图添加标记&quot;">​</a></h3><p>火焰图是很棒的工具，但要找到代码在何时何地执行可能会很棘手 - 特别是当有几十个其他插件同时运行代码时。</p><p>幸运的是，<a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance_API/Performance_data" target="_blank" rel="noreferrer"><code>performance API</code></a> 提供了一些方法，可以在 <code>Timings</code> 下向图表添加标记</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 测量代码执行时间并在 Performance 火焰图的 &#39;Timings&#39; 下标记</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">performance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mark</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;start&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在此处放置你的耗时代码</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">performance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mark</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;end&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> code_perf</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> performance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">measure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;label&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;start&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;end&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可用于计算平均值并记录</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><img src="https://fevol.github.io/obsidian-typings/_astro/flame-chart-markings.uxD3krqH_M8flY.webp" alt="带有特定代码块标记的火焰图"></p><h3 id="解读你的火焰图" tabindex="-1">解读你的火焰图 <a class="header-anchor" href="#解读你的火焰图" aria-label="Permalink to &quot;解读你的火焰图&quot;">​</a></h3><p>如前所述，<strong>宽</strong>块是性能不佳的根本原因。在我展示的示例中（我的插件），执行一个渲染函数需要 20ms（如 <code>Summary</code> 中给出的 <code>Total Time</code> 所示）。</p><p>通过图表，你可以轻松地向下滚动火焰图（或查看 <code>Call Tree</code>）来确切地看到为什么函数性能不佳。在我的例子中，我注意到大量时间都花在运行 <code>MarkdownRenderer.render</code> 函数上。</p><p>最后，在检测到性能瓶颈后，你可以采取措施减少其使用并确保尽可能少地调用它，或者编写一个更高效的函数。</p><h3 id="额外提示" tabindex="-1">额外提示 <a class="header-anchor" href="#额外提示" aria-label="Permalink to &quot;额外提示&quot;">​</a></h3><p>当你有一个 <code>Performance Snapshot</code> 时，你可以转到 <code>Sources</code> 标签页，它现在会在（某些）代码行旁边显示毫秒级的持续时间，这可以指示执行特定行/函数需要多长时间</p><p>（注意：这个持续时间具体代表什么在任何地方都没有明确记录）</p><p><img src="https://fevol.github.io/obsidian-typings/_astro/flame-chart-snapshot.CPxOEuaT_1lwlKI.webp" alt="Sources 标签页中的性能指标"></p>`,41),t=[l];function p(r,o,h,d,c,k){return i(),a("div",null,t)}const u=s(n,[["render",p]]);export{g as __pageData,u as default};
