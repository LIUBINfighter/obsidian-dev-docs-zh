import{_ as s,c as i,o as a,V as n}from"./chunks/framework.qP9-rlTe.js";const g=JSON.parse('{"title":"分析压缩后的源代码","description":"学习如何分析压缩后的源代码以理解未文档化函数的行为。","frontmatter":{"title":"分析压缩后的源代码","description":"学习如何分析压缩后的源代码以理解未文档化函数的行为。"},"headers":[],"relativePath":"zh/articles/typings/analyzing-source-code.md","filePath":"zh/articles/typings/analyzing-source-code.md","lastUpdated":1742991136000}'),e={name:"zh/articles/typings/analyzing-source-code.md"},l=n(`<h1 id="分析压缩后的源代码" tabindex="-1">分析压缩后的源代码 <a class="header-anchor" href="#分析压缩后的源代码" aria-label="Permalink to &quot;分析压缩后的源代码&quot;">​</a></h1><blockquote><p><a href="https://fevol.github.io/obsidian-typings/guides/analyzing-source-code/" target="_blank" rel="noreferrer">Analyzing minified source code | Obsidian Typings (fevol.github.io)</a></p></blockquote><h2 id="遍历和分析源代码" tabindex="-1">遍历和分析源代码 <a class="header-anchor" href="#遍历和分析源代码" aria-label="Permalink to &quot;遍历和分析源代码&quot;">​</a></h2><p>有时仅仅查看函数名称并不足以理解它的功能，这就是为什么查看压缩源代码中的实际函数定义会很有帮助。</p><p>首先打开控制台，然后进入 <code>Sources</code> 标签页。在这里你会找到定义了所有内部方法的 <code>app.js</code> 文件。</p><ol><li>进入 <code>Sources</code> 标签页</li><li>选择 <code>app.js</code> 文件</li><li><code>格式化代码</code>（可选）</li><li>将代码复制到你选择的 IDE 中（可选，但推荐）</li></ol><p><img src="https://fevol.github.io/obsidian-typings/_astro/accessing-main.D0s46UhZ_Qm9EM.webp" alt="展示如何访问 "></p><p>有了压缩代码的访问权限后，你就可以开始搜索并找到你想要查看的方法的定义。</p><p>对于任何方法 &quot;XYZ&quot;，首先直接搜索 &quot;XYZ&quot;。通常，方法的定义方式有以下几种：</p><ul><li><code>t.XYZ = ...</code>（静态方法）</li><li><code>t.prototype.XYZ = ...</code>（原型方法）</li><li><code>function XYZ(</code>（内部/压缩方法）</li></ul><p>在这个阶段，你可能会很幸运地找到单一的定义，或者可能会找到多个方法定义。 在后一种情况下， 你需要尝试查看代码上下文来确定该方法属于哪个接口/类。 找到正确定义的主要技巧是，查看在原型上定义的其他方法， 并检查这些方法是否与你的对象的其他方法匹配。</p><p>找到正确的定义行后，你就可以开始分析代码来确定输入/输出类型 及其行为。</p><p>例如，<code>requestSaveConfig</code> 方法（前面提到过）的定义如下：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">n.requestSaveConfig </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> at</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n.saveConfig.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1e3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在这里，我们发现了以下三点：</p><ul><li><code>at</code> 是一个接受三个参数的压缩函数，其返回值就是该方法的返回值</li><li><code>1e3</code> 是 <code>1000</code> 的简写表示法</li><li><code>!0</code> 是 <code>true</code> 的简写表示法</li></ul><p>（在压缩代码中，你需要习惯很多这样的简写和结构变化）</p><p>由于我们不知道 <code>at</code> 的作用，我们需要再次搜索代码。确保启用大小写敏感和全字匹配搜索，因为 <code>at</code> 是一个很常见的词。 开始搜索 <code>function at</code> 或 <code>.prototype.at</code>。如果幸运的话，这会带你找到以下定义：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> at</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        o </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        l</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> o,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            /*   ...    */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>你可能想要通过你喜欢的 LLM 或反压缩工具来处理代码，使其至少变得稍微可以理解。 根据你是否成功解密了代码，你现在可以明确定义该方法的行为和/或类型。</p><h3 id="异步函数" tabindex="-1">异步函数 <a class="header-anchor" href="#异步函数" aria-label="Permalink to &quot;异步函数&quot;">​</a></h3><p>逆向工程异步函数更具挑战性。</p><p>在 <code>app.js</code> 中，你不会看到很多 <code>async</code> 函数。大多数都被转换成了等效的状态机代码。</p><ul><li>如果你的函数包含 <code>v(this, void 0,</code>，那它就是一个异步函数。</li><li>如果你的函数包含 <code>return [2]</code>，你的函数不返回任何内容，函数的返回类型将是 <code>Promise&lt;void&gt;</code>。</li><li>如果你的函数包含 <code>return [2, someValue]</code>，你的函数返回 <code>someValue</code>，函数的返回类型将是 <code>Promise&lt;TypeOfSomeValue&gt;</code>。</li><li>如果你的函数包含 <code>return [4, someValue]</code>，它对应于 <code>await someValue</code>，稍后通过 <code>n.sent()</code> 获取等待的值。</li></ul><p>关于它具体如何工作的更多细节，请参见 <a href="https://github.com/microsoft/tslib/blob/main/docs/generator.md" target="_blank" rel="noreferrer">The <code>__generator</code> helper</a> 文档。</p>`,25),p=[l];function t(h,k,r,d,o,c){return a(),i("div",null,p)}const y=s(e,[["render",t]]);export{g as __pageData,y as default};
